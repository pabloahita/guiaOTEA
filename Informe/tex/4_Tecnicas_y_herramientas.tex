\capitulo{4}{Técnicas y herramientas}

%Esta parte de la memoria tiene como objetivo presentar las técnicas
%metodológicas y las herramientas de desarrollo que se han utilizado para llevar
%a cabo el proyecto. Si se han estudiado diferentes alternativas de metodologías,
%herramientas, bibliotecas se puede hacer un resumen de los aspectos más
%destacados de cada alternativa, incluyendo comparativas entre las distintas
%opciones y una justificación de las elecciones realizadas. No se pretende que
%este apartado se convierta en un capítulo de un libro dedicado a cada una de las
%alternativas, sino comentar los aspectos más destacados de cada opción, con un
%repaso somero a los fundamentos esenciales y referencias bibliográficas para que
%el lector pueda ampliar su conocimiento sobre el tema. 

\section{\textit{Microsoft Azure}}
 \textit{Microsoft Azure} es una plataforma que proporciona diferentes servicios
 en la nube, permitiendo la construcción, prueba, despliegue y administración de
 los mismos. Esta plataforma fue anunciada en el año 2010 por Microsoft con el
 nombre de \textit{Windows Azure}, pasando a su denominación actual el 25 de
 marzo del año 2014.
\\
En este proyecto se utiliza \textit{Azure} para desplegar la aplicación web que
es utilizada para la gestión de las operaciones de la base de datos. La
aplicación web está desplegada mediante el servicio denominado \textit{Web
Service}, el cual es utilizado para el despliegue de aplicaciones web hechas en
diferentes tecnologías de diferentes lenguajes de programación, destacando C\#,
Java y Python. Mientras tanto, la base de datos es implementada utilizando
\textit{SQL Server} mediante el servicio denominado \textit{Azure SQL}, el cual
proporciona la cadena de conexión necesaria para el servicio web, crea el
servidor de base de datos y proporciona el soporte necesario para la ejecución
de consultas en SQL.
\\
Para poder utilizar \textit{Microsoft Azure}\cite{azureMainPage}, es preciso contar con una cuenta
con la cual se tienen ciertos servicios de forma gratuita, algunos de ellos de forma
permanente y otros tantos durante un total de 12 meses. Adicionalmente a esta base, se pueden
añadir servicios o mejorar los ya existentes a partir de diferentes niveles de
suscripción a los mismos, los cuales se ajustan a las necesidades que tengan los
usuarios u organizaciones para sus actividades. Para cubrir dichas actividades,
\textit{Microsoft Azure} proporciona un crédito inicial de 200\$ para utilizarse
durante el primer año, el cual puede ampliarse de forma opcional eligiendo un
método de pago, ya sea mediante transferencia bancaria o mediante tarjeta de
crédito o de débito.
\\
En primera instancia, el inicio del despliegue de la aplicación en
\textit{Microsoft Azure} se ha realizado con la propia cuenta de la Universidad
de Burgos \cite{azureUBU}, el cual permite el uso
de \textit{Azure for Education} \cite{azureEDU} ya que se
trata de uno de los diferentes servicios de \textit{Microsoft 365} del cual
disponen los alumnos de manera gratuita, la cual destaca por un crédito inicial
de 100\$ y por no necesitar introducir un método de pago para la creación de la
cuenta. A posteriori, la implementación definitiva de la aplicación se ha
realizado en el propio servidor de la \textit{Fundación Miradas}, disponiendo
para ello con una cuenta diferente a la de la Universidad de Burgos. \\
En cuanto al aprendizaje de la herramienta, se dispone de una herramienta de
aprendizaje denominada \textit{Microsoft Learn} \cite{MicrosoftLearn}, la cual
consta de diferentes cursos autodidactas e interactivos sin restricción alguna
en cuanto a horarios, permitendo un aprendizaje adaptado al ritmo que cada
usuario tenga y al tiempo que éste le pueda dedicar a los mismos.
\textit{Microsoft Learn} también dispone de diferentes herramientas alternativas
para incrementar la experiencia y el aprendizaje del usuario, como la presencia
de foros y la búsqueda de documentación técnica sobre las diferentes
herramientas de \textit{Microsoft}. En última instancia, \textit{Microsoft
Learn} también ofrece la obtención de diferentes certificados oficiales de
\textit{Microsoft}, adaptados al rol que desempeña cada usuario en el equipo de
trabajo, todo ello gracias a los cursos y módulos de aprendizaje
correspondientes, aunque para conseguir esa certificación se necesita realizar
un examen previo pago de una tasa de inscripción al mismo.



\section{Entornos de desarrollo utilizados}
\subsection{\textit{Microsoft Visual Studio}} 

Para el desarrollo del lado del servidor se ha optado por utilizar
\textit{Microsoft Visual Studio Community}, la cual se trata de la versión más
básica de este entorno de desarrollo, si no consideramos que se tiene \textit{Microsoft
Visual Studio Code}. Dicho entorno de desarrollo es gratuito, por lo que no
supone ningún coste adicional con respecto a sus versiones \textit{Enterprise} y
\textit{Professional}, los cuales sí que tienen una licencia de pago con
posibilidad de probar el software de manera gratuita.
\\
Visual Studio es una herramienta de desarrollo eficaz que permite completar todo
el ciclo de desarrollo en un solo lugar. Es un entorno de desarrollo integrado
 completo que permite la escritura, edición, depuración y compilación del
código y, luego, su posterior implementación. Aparte de la edición y depuración
del código, Visual Studio incluye compiladores, herramientas de finalización de
código, control de código fuente, extensiones y muchas más características para
mejorar cada fase del proceso de desarrollo de software. \\
Visual Studio proporciona a los desarrolladores un entorno de desarrollo
enriquecido para desarrollar código de alta calidad de forma eficaz y
colaborativa:\cite{vs2022Learn}
\begin{itemize}
    \item Instalador basado en cargas de trabajo: instale solo lo que necesita.
    \item Herramientas y características de codificación eficaces: todo lo que necesita
    para compilar sus aplicaciones en un solo lugar. 
    \item Compatibilidad con varios lenguajes: código en C++, C\#, JavaScript, TypeScript, Python, etc. 
    \item Desarrollo multiplataforma: compilación de aplicaciones para cualquier plataforma.
    \item Integración del control de versiones: colaboración en el código con compañeros de equipo.
\end{itemize}


El motivo por el cual se ha utilizado este entorno de desarrollo para el lado
del servidor es por los cursos de \textit{Azure Learn} que se han ido siguiendo
para el aprendizaje de las herramientas de Azure para este tipo de aplicaciones,
aunque también pueda utilizarse \textit{Microsoft Visual Studio Code} para la
programación del lado del servidor. Al haber realizado el aprendizaje de esta
manera, no se necesita realizar aprendizaje de otras herramientas, ayudando a
reforzar dicha decisión.\\

Por lo tanto, las principales características de este entorno de desarrollo son las siguientes:\cite{vs2022LearnCar}
\begin{itemize}
    \item \textbf{Instalación modular:} En el instalador modular de Visual
    Studio, se eligen y se instalan exclusivamente las cargas de trabajo que
    sean necesarias. Las cargas de trabajo son grupos de características que los
    lenguajes de programación o las plataformas necesitan para funcionar. Esta
    estrategia modular ayuda a reducir la superficie de instalación de Visual
    Studio, por lo que se instala y actualiza más rápido.
    \item \textbf{Creación de aplicaciones de Azure habilitadas para la nube: }
    Visual Studio ofrece un conjunto de herramientas para crear fácilmente
    aplicaciones habilitadas para la nube de Microsoft Azure, permitiendo la
    configuración, compilación, depuración, empaquetado e implementación de
    aplicaciones y servicios de Azure directamente desde el entorno de
    desarrollo integrado (IDE). Para obtener las plantillas de proyecto y las
    herramientas de Azure, se tiene que seleccionar la carga de trabajo
    Desarrollo de Azure al instalar Visual Studio.
    \item \textbf{Creación de aplicaciones web: } Visual Studio puede crear
    aplicaciones web mediante ASP.NET, Node.js, Python, JavaScript y TypeScript.
    Visual Studio admite muchos marcos web, como Angular, jQuery y Express.
    ASP.NET Core y .NET Core funcionan en los sistemas operativos Windows, Mac y
    Linux. ASP.NET Core es una actualización principal a MVC, WebAPI y SignalR.
    ASP.NET Core se diseñó desde la base para ofrecer una pila de .NET eficiente
    y componible, con el fin de compilar servicios y aplicaciones web modernos
    basados en la nube.
    \item \textbf{Compilar aplicaciones y juegos multiplataforma: } Visual
    Studio puede crear aplicaciones y juegos para macOS, Linux y Windows, así
    como para Android, iOS y otros dispositivos móviles. Con Visual Studio,
    puede crear: 
    \begin{itemize}
        \item Aplicaciones de .NET Core que se ejecutan en Windows, macOS y
        Linux.
        \item Aplicaciones móviles para iOS, Android y Windows en C\# y F\#
        medianteXamarin.
        \item Juegos 2D y 3D en C\# mediante Visual Studio Tools para Unity.
        \item Aplicaciones de C++ nativas para dispositivos iOS, Android y
        Windows. Comparta código común en bibliotecas para iOS, Android y
        Windows mediante C++ para desarrollo multiplataforma.
    
    \end{itemize}
    \item \textbf{Conectarse a bases de datos: } El Explorador de servidores
    ayuda a explorar y administrar instancias y recursos de servidor de forma
    local y remota, y en Azure, Microsoft 365, Salesforce.com y sitios web.
    
    El Explorador de objetos de SQL Server ofrece una vista de los objetos de
    base de datos similar a la de SQL Server Management Studio. Con el
    Explorador de objetos de SQL Server puede realizar trabajos de
    administración y diseño de bases de datos ligeras. Algunos ejemplos son la
    edición de datos de tabla, la comparación de esquemas y la ejecución de
    consultas mediante menús contextuales.
    \item \textbf{Depuración y pruebas: }Con el sistema de depuración de Visual
    Studio, es posible depurar el código que se ejecuta en el proyecto local, en
    un dispositivo remoto o en un emulador de dispositivo. Es posible ejecutar
    el código una instrucción cada vez, inspeccionandp las variables mientras se
    avanza. O bien, se pueden establecer puntos de interrupción que solo se
    alcanzan cuando una condición especificada es verdadera. Se pueden
    administrar las opciones de depuración en el propio editor de código para
    que no tenga que salir del código.Visual Studio ofrece opciones de prueba,
    como pruebas unitarias, Live Unit Testing, IntelliTest y pruebas de carga y
    rendimiento. Visual Studio también cuenta con funciones avanzadas de
    análisis de código para detectar errores de diseño, de seguridad y de otro
    tipo.
    \item \textbf{Implementación de la aplicación finalizada: }Visual Studio
    dispone de herramientas para implementar las aplicaciones en usuarios o
    clientes mediante Microsoft Store, un sitio de SharePoint o las tecnologías
    de InstallShield o Windows Installer.
    \item \textbf{Administrar el código fuente: }En Visual Studio, se puede
    administrar el código fuente en los repositorios de Git hospedados por
    cualquier proveedor, incluido GitHub. También puede buscar una instancia de
    Azure DevOps Server a la que conectarse.
\end{itemize}

\subsection{\textit{Android Studio}} 
Para el desarrollo del lado del cliente se ha decidido utilizar Android
Studio, el cual es el entorno de desarrollo integrado oficial de Google para
aplicaciones en Android. Desde el 7 de marzo del 2019 Kotlin es el lenguaje de
programación preferido de Google para el desarrollo de aplicaciones en Android,
aunque esta IDE también permita la implementación de las mismas en el lenguaje
Java. \cite{androidStudio}

Está basado en el software IntelliJ IDEA de JetBrains y ha sido publicado de
forma gratuita a través de la Licencia Apache 2.0. Está disponible para las
plataformas GNU/Linux, macOS, Microsoft Windows y Chrome OS. Ha sido diseñado
específicamente para el desarrollo de Android.

Como lenguaje de programación se ha utilizado Java, ya que es un lenguaje que se
ha utilizado a lo largo de la carrera en diferentes asignaturas, siendo uno de
los lenguajes de programación más utilizados en los últimos años. Para el
desarrollo del lado del cliente se ha optado por este entorno de desarrollo
debido a que ya se sabía manejar de la asignatura de \textit{Interacción
Hombre-Máquina} del cuarto semestre de este grado, aun sabiendo que se tenía la
opción de utilizar el mismo entorno que en el lado del servidor. 

Las características de la versión más reciente de Android Studio a fecha de la
entrega de segunda convocatoria, teniendo en cuenta que siempre se añaden nuevas
funcionalidades en cada una de sus versiones, son las siguientes:\cite{AndroidStudioWiki}

\begin{itemize}
    \item El soporte para la construcción de las aplicaciones está basado en
    Gradle, el cual ayuda a automatizar y administrar el proceso de compilación
    de las mismas mediante las dependencias que va añadiendo el usuario.
    \item La refactorización del código y de su estructura es específica de
    Android, teniendo también la posibilidad de realizar arreglos rápidos.
    \item Posee también herramientas Lint para detectar problemas de
    rendimiento, usabilidad, compatibilidad de versiones y otros problemas.
    Dichas herramientas han sido de gran utilidad para poder detectar los
    diferentes errores que han impedido que la aplicación se mostrase de la manera adecuada
    \item Integración de ProGuard y funciones de firma de aplicaciones. ProGuard
    es utilizado para la reducción y optimización del código de la aplicación
    del código, con la finalidad de que el rendimiento sea óptimo en los
    dispositivos móviles en los que se ejecuta la aplicación. 
    \item Android Studio cuenta también con diferentes plantillas para crear
    diseños comunes de Android y otros componentes, pudiendo modificarse
    mediante un editor de diseño enriquecido que permite a los usuarios
    arrastrar y soltar componentes de la interfaz de usuario. Esta
    característica es fundamental para ayudar al desarrollador a elegir los
    mejores diseños base para las diferentes actividades de su aplicación, por
    lo que no es necesario tener amplios conocimientos en el lenguaje XML para
    empezar a desarrollarla. 
    \item Android Studio también tiene soporte para programar aplicaciones para
    diferentes dispositivos, entre los cuales destacamos los teléfonos móviles,
    las tabletas, las aplicaciones de escritorio y los dispositivos de Android
    Wear.
    \item Android Studio tiene soporte integrado para Google Cloud Platform, que permite la
    integración con Firebase Cloud Messaging (antes 'Google Cloud Messaging') y
    Google App Engine.
    \item Para realizar las pruebas de la aplicación se cuenta con un
    dispositivo virtual de Android, teniendo también el soporte para la
    depuración inalámbrica para dispositivos físicos.
    \item El renderizado se realiza en tiempo real.
    \item Android Studio tiene su propia consola de desarrollador, además de
    tener la capacidad de integrar diferentes terminales dependiendo del sistema
    operativo que se esté utilizando.
\end{itemize}

Apoyándonos en las características anteriormente mencionadas, las principales
ventajas de utilizar Android Studio son las siguientes:
\begin{itemize}
    \item Como se ha mencionado con anterioridad, es la IDE oficial de Google
    para el desarrollo de aplicaciones de Android, desbancando a Eclipse en el
    año 2013.
    \item Permite la conversión de código Java a código Kotlin, algo que es
    imposible en otras IDEs como Eclipse, ya que Kotlin es un lenguaje el cual
    se ejecuta sobre una máquina virtual de Java, permitiendo también utilizar
    sus librerías.
    \item Permite programar la interfaz de la aplicación de forma interactiva,
    todo ello mediante los ficheros .xml del directorio /res/layout, pudiendo
    intercalar de forma sencilla entre la forma interactiva y el código .xml.
    \item Permite simular el funcionamiento de la aplicación sobre diferentes
    dispositivos, ya sean virtuales mediante su emulador, o físicos pudiendo
    conectar diferentes dispositivos mediante las opciones de desarrollador de
    los dispositivos Android.
    \item Permite inicializar proyectos a partir de plantillas preestablecidas,
    siendo de gran utilidad tanto para principiantes como para expertos.
    \item Permite la creación de módulos de Java, no sólo de módulos de Android,
    permitiendo así ejecutar esos módulos a parte para el desarrollo de
    diferentes pruebas para la versión básica de la ejecución del código de
    indicadores en línea de comandos.
\end{itemize} 
En contraparte, los principales inconvenientes de Android Studio son los siguientes:
\begin{itemize}
    \item Android Studio dificulta mucho la unificación del desarrollo de
    aplicaciones cliente-servidor bajo un mismo entorno, ya que resulta muy
    tedioso ejecutar tanto la aplicación como el servidor en dos hilos
    diferentes.
    \item Android Studio no soporta otros lenguajes de programación diferentes
    de Java y Kotlin, por lo tanto no se puede programar el servidor de
    \textit{ASP.NET} en C\#, obligando al uso de otra IDE distinta para su
    implementación, como \textit{Visual Studio 2022}.
    \item El emulador de Android Studio en ocasiones tiene un desempeño que deja
    mucho que desear debido a su inestabilidad en tiempo de ejecución,
    sucediendo lo mismo con el desarrollo de los layout de las actividades, que
    en los modos \textit{Split} y \textit{Design} tiene diferentes problemas de
    renderización. Afortunadamente estos problemas no se han trasladado a los
    dispositivos físicos en los que se han realizado las pruebas, solventando el
    pobre desempeño que pueda tener el emulador.
    \item Android Studio no tiene un soporte nativo de Azure debido a que
    Android Studio es de Google y Azure es de Microsoft. Eso obliga al usuario a
    tener que buscar otro entorno diferenciado para poder realizar la
    implementación del lado del servidor, algo que se tuvo que hacer casi al
    final del tiempo de desarrollo del mismo, cuando se pasó de tratar de
    implementar un servidor embedido en la aplicación para la realización de
    preuebas del servidor en local, obligando a hacer este cambio para avanzar
    con el desarrollo
\end{itemize}
    
\section{Lenguajes de programación y herramientas utilizadas}
\subsection{Lado del cliente}
\subsubsection{\textit{Java}} En el lado del cliente se ha utilizado Java como
lenguaje de programación debido a que, como se ha mencionado en la sección
anterior, dicho lenguaje ya se había utilizado en las asignaturas del grado de
Metodología de la Programación, Estructuras de Datos, Interacción
Hombre-Máquina, Programación Concurrente y de Tiempo Real, Aplicaciones de Bases
de Datos, Testes e Qualidade de Software (equivalente en el \textit{Instituto
Superior de Engenharia de Coimbra} a la asignatura Validación de Datos de esta
universidad) y Sistemas Distribuidos, además de las asignaturas de máster
Arquitectura y servicios de internet y Sistemas de Información Avanzados. Por lo
que esta decisión viene respaldada por la experiencia otorgada por los docentes
de dichas asignaturas durante todo el grado. \\
Java es un lenguaje de programación y una plataforma informática que fue
comercializada por primera vez en 1995 por Sun Microsystems.
\\
El lenguaje de programación Java fue desarrollado originalmente por James
Gosling, de Sun Microsystems (en la actualidad propiedad de Oracle), y
publicado en 1995 como un componente fundamental de la plataforma Java de Sun
Microsystems. Su sintaxis deriva en gran medida de C y C++, pero tiene menos
utilidades de bajo nivel que cualquiera de ellos. Las aplicaciones de Java son
compiladas a bytecode (clase Java), que puede ejecutarse en cualquier máquina
virtual Java (JVM) sin importar la arquitectura de la computadora subyacente.
\\
Por lo tanto, para el lado del cliente se han utilizado las siguientes herramientas de Java:
\begin{itemize}
    %Sustituir AsyncTask. Decir que AsyncTask ha sido sustituido por java.util.concurrent y por CompletableFuture dependiendo de las exigencias 
    \item \texttt{java.util.concurrent}
    \begin{lstlisting}
        
    \end{lstlisting}
    
    \item \textit{OKHttp: }
    OkHttp es un cliente HTTP que es eficiente por defecto, ya que:
    \begin{itemize}
        \item El soporte de HTTP/2 permite que todas las solicitudes al mismo
        servidor compartan un socket.
        \item La agrupación de conexiones reduce la latencia de las solicitudes
        (si no está disponible HTTP/2).
        \item La compresión transparente GZIP reduce el tamaño de las descargas.
        \item La caché de respuestas evita completamente la red en las
        solicitudes repetidas.
        \item OkHttp persevera cuando la red tiene problemas: se recuperará
        silenciosamente de problemas de conexión comunes. Si tu servicio tiene
        múltiples direcciones IP, OkHttp intentará con direcciones alternativas
        si la primera conexión falla. Esto es necesario para IPv4+IPv6 y
        servicios alojados en centros de datos redundantes. OkHttp admite
        funciones TLS modernas (TLS 1.3, ALPN, verificación de certificado). Se
        puede configurar para que tenga una conexión alternativa para una amplia
        conectividad.
    \end{itemize}
    Usar OkHttp es fácil. Su API de solicitud/respuesta está diseñada con
    constructores fluidos e inmutabilidad. Admite tanto llamadas de bloqueo
    síncronas como llamadas asíncronas con devoluciones de llamada.
    
    En este caso \textit{OKHttp} se utiliza en conjunto con \textit{Retrofit}
    para la construcción de un cliente nuevo mediante la función
    \texttt{OkHttpClient().newBuilder().build()}:
    \begin{lstlisting}
        client=new OkHttpClient().newBuilder().build();
    \end{lstlisting}
    
    \item \textit{Retrofit: }\textit{Retrofit }es la clase a través de la cual las
    interfaces de API se convierten en objetos invocables. Por defecto, \textit{Retrofit}
    proporciona valores predeterminados sensatos, pero también permite
    personalización. Por defecto, Retrofit solo puede deserializar cuerpos HTTP
    en el tipo \texttt{ResponseBody} de OkHttp y solo puede aceptar su tipo RequestBody
    para la anotación \texttt{@Body}. Por lo tanto, un ejemplo de Retrofit es el siguiente:
    \begin{lstlisting}
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.github.com/")
                .addConverterFactory(GsonConverterFactory.create())
                .build();
    \end{lstlisting}
    Como se ha mencionado con anterioridad, \textit{Retrofit} se utiliza en
    conjunto con \textit{OkHttp} para poder enviar las peticiones al servidor y
    poder recibir posteriormente sus respuestas. \textit{Retrofit} proporciona
    las etiquetas necesarias para indicar a las APIs el tipo de consulta a
    realizar \texttt{@GET, @POST, @PUT y @DELETE}, el cuerpo a enviar junto con
    la solicitud \texttt{@Body} y los atributos a añadir al path \texttt{@Path}.
\end{itemize}
\subsection{Lado del servidor}
\subsubsection{\textit{C\#}} Para el lado del servidor se ha decidido utilizar
C\# como lenguaje de programación, aunque en la gran mayoría de la fase de
desarrollo se haya pretendido utilizar el mismo lenguaje para implementar toda
la aplicación cliente servidor, utilizando JDBC para la conexión de la base de
datos y JAX-RS como API para la aplicación web, se ha optado finalmente por C\#
junto con el framework de ASP.NET debido a que dicho lenguaje y dicho framework
tienen el soporte integrado en \textit{Azure} para la implementación y posterior
despliegue de la aplicación web que soporta la base de datos, lo que ha hecho
que los tiempos de respuesta de las solicitudes sean bastante más cortos en
comparación con la alternativa anteriormente mencionada basada en Java.

C\# es un lenguaje de programación multiparadigma desarrollado y estandarizado
por la empresa Microsoft como parte de su plataforma .NET, que después fue
aprobado como un estándar por la ECMA (ECMA-334) e ISO (ISO/IEC 23270). C\# es
uno de los lenguajes de programación diseñados para la infraestructura de
lenguaje común. Su sintaxis básica está basada en C y C++, utilizando también el
modelo de objetos de la plataforma .NET, similar al de Java, lo que ha
favorecido al rápido aprendizaje de este lenguaje.\cite{CSharp}


\cite{ASP.NET}
\textit{ASP.NET Core} es un marco multiplataforma de
    código abierto y de alto rendimiento cuyo fin es compilar aplicaciones que
    se encuentran en internet o en la nube. Este marco da la posibilidad de :
    \begin{itemize}
        \item Compilar servicios y aplicaciones web, aplicaciones de Internet de las cosas (IoT) y back-ends móviles.
        \item Efectuar implementaciones locales y en la nube.
        \item Ejecutar en .NET Core.
    \end{itemize}

    Las principales ventajas que tiene \textit{ASP.NET} con respecto a su competencia son las siguientes:
    \begin{itemize}
        \item Da la posibilidad de crear una aplicación cliente-servidor de forma unificada, aunque este no haya sido el caso.
        \item Está diseñado para realizar pruebas
        \item ASP.NET dispone de las Razor Pages, que se trata un modelo de programación
        basado en páginas que facilita la compilación de interfaces de usuario
        web y hace que sea más productiva.
        \item Blazor permite usar C\# en el explorador, junto con JavaScript, permitiendo compartir la lógica entre el cliente y el servidor.
        \item Capacidad para desarrollarse y ejecutarse en cualquier sistema operativo.
        \item De código abierto y centrado en la comunidad.
        \item Integración de marcos del lado cliente modernos y flujos de trabajo de desarrollo.
        \item Compatibilidad con el hospedaje de servicios de llamada a procedimiento remoto con gRPC.
        \item Un sistema de configuración basado en el entorno y preparado para la nube.
        \item Tiene la inserción de dependencias integrada.
        \item Tiene una canalización de solicitudes HTTP ligera, modular y de alto rendimiento.
        \item Tiene la capacidad de hospedar diferentes tipos de servidores.
        \item Control de versiones en paralelo.
        \item Herramientas que simplifican el desarrollo web moderno.
    \end{itemize}

\subsubsection{Inicio de sesión}
Para poder iniciar sesión, se ha creado un método \texttt{POST} denominado \texttt{login:}
El método \texttt{Login} es un controlador en ASP.NET que maneja peticiones HTTP POST en la ruta \texttt{"login"}. Este método permite a los usuarios autenticarse proporcionando sus credenciales en formato JSON. A continuación se describe su funcionamiento, destacando especialmente cómo se genera el token y bajo qué condiciones se generan.

\begin{itemize}
    \item El método está decorado con los atributos \texttt{[HttpPost("login")]} y \texttt{[AllowAnonymous]}, lo que indica que este método responderá a las solicitudes POST en la ruta \texttt{"login"} y no requiere autenticación previa para acceder.
    \item El método recibe un parámetro \texttt{credentials} del cuerpo de la solicitud (\texttt{[FromBody]}), que es un documento JSON. Se espera que este JSON contenga las propiedades \texttt{email} y \texttt{password}.
    \item Dentro del bloque \texttt{try}, se extraen el \texttt{email} y \texttt{password} del \texttt{credentials}:
    \begin{lstlisting}
    string email = credentials.RootElement.GetProperty("email").ToString();
    string password = credentials.RootElement.GetProperty("password").ToString();
    \end{lstlisting}
    \item Se busca al usuario en la base de datos utilizando el contexto \texttt{\_context}:
    \begin{lstlisting}
    var user = _context.Users.FirstOrDefault(u => u.emailUser == email && u.passwordUser == password && u.isActive == 1);
    \end{lstlisting}
    \item Si el usuario no se encuentra o no está activo (\texttt{isActive == 1}), se realiza otra búsqueda solo por \texttt{email} para verificar si el usuario existe:
    \begin{itemize}
        \item Si no se encuentra ningún usuario con ese \texttt{email}, se devuelve un \texttt{NotFound()}.
        \item Si el \texttt{password} es incorrecto, se devuelve un \texttt{Unauthorized()}.
    \end{itemize}
    \item Si el usuario es encontrado y las credenciales son correctas, se procede a generar un token JWT:
    \begin{lstlisting}
    var tokenHandler = new JwtSecurityTokenHandler();
    var key = Encoding.ASCII.GetBytes(_sessionConfig.secret);
    var tokenDescriptor = new SecurityTokenDescriptor
    {
        Subject = new ClaimsIdentity(new Claim[]
        {
            new Claim(ClaimTypes.Name, user.emailUser),
            new Claim(ClaimTypes.Role, user.userType)
        }),
        Expires = DateTime.UtcNow.AddHours(12),
        SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
    };
    var token = tokenHandler.CreateToken(tokenDescriptor);
    string sessionToken = tokenHandler.WriteToken(token);
    \end{lstlisting}
    \item El token JWT se genera usando el \texttt{JwtSecurityTokenHandler} y contiene los siguientes elementos:
    \begin{itemize}
        \item \texttt{ClaimsIdentity} con dos claims: el nombre del usuario (\texttt{ClaimTypes.Name}) y el rol del usuario (\texttt{ClaimTypes.Role}).
        \item La fecha de expiración del token, configurada para 12 horas desde la generación.
        \item Credenciales de firma (\texttt{SigningCredentials}) utilizando una clave simétrica (\texttt{SymmetricSecurityKey}) y el algoritmo HMAC-SHA256.
    \end{itemize}
    \item Se crea un objeto \texttt{usr} que contiene información del usuario autenticado.
    \item Se busca la organización asociada al usuario:
    \begin{lstlisting}
    var organization = _context.Organizations.FirstOrDefault(o => o.idOrganization == user.idOrganization && o.orgType == user.orgType && o.illness == user.illness);
    \end{lstlisting}
    \item Si no se encuentra la organización, se devuelve un \texttt{BadRequest()}.
    \item Se crea un objeto \texttt{org} con la información de la organización.
    \item Finalmente, se construye una respuesta que contiene la información del usuario, la información de la organización y el token JWT:
    \begin{lstlisting}
    var response = new
    {
        user = usr,
        organization = org,
        token = "Bearer " + sessionToken
    };
    return Ok(response);
    \end{lstlisting}
\end{itemize}

En resumen, el método \texttt{Login} autentica al usuario mediante sus
credenciales, genera un token JWT si las credenciales son correctas y el usuario
está activo, y devuelve una respuesta que incluye la información del usuario, la
organización y el token JWT.
\\
El proceso de autorización de acceso a ciertos métodos en una aplicación
ASP.NET, después de que un usuario obtiene un token JWT en el login, se maneja
mediante políticas de autorización definidas en el archivo Program.cs y los
atributos de autorización en los controladores. Aquí está una explicación
detallada del funcionamiento:
\\
\begin{itemize}
    \item \textbf{Definición de Políticas de Autorización: }En
    \texttt{Program.cs}, se definen varias políticas de autorización con roles
    específicos:
    \begin{lstlisting}
        builder.Services.AddAuthorization(options =>
        {
            options.AddPolicy("Administrator", policy =>
                policy.RequireRole("ADMIN")); 

            options.AddPolicy("Director", policy =>
                policy.RequireRole("DIRECTOR"));

            options.AddPolicy("Organization", policy => 
                policy.RequireRole("ORGANIZATION"));
        });
    \end{lstlisting}
    \begin{itemize}
        \item Política \textbf{\textit{Administrator:}} Solo los usuarios con el
        rol \texttt{ADMIN} pueden acceder a métodos que requieren esta política.
        \item Política \textbf{\textit{Director:}} Solo los usuarios con el rol
        \texttt{DIRECTOR} pueden acceder a métodos que requieren esta política.
        \item Política \textbf{\textit{Organization:}} Solo los usuarios con el
        rol \texttt{ORGANIZATION} pueden acceder a métodos que requieren esta
        política.
    \end{itemize}
    \item \textbf{Uso de los Métodos con Autorización: }
    \begin{itemize}
        \item Este método está marcado con el atributo \texttt{[AllowAnonymous]}, lo que
        significa que no requiere autenticación ni autorización:
        \begin{lstlisting}
            [HttpGet("get")]
            [AllowAnonymous]
            public ActionResult<Organization> Get([FromQuery] int id, [FromQuery] string orgType, [FromQuery] string illness)
            {
                // Implementacion del metodo
            }

        \end{lstlisting}
        \item Este método está protegido por la política \texttt{Administrator}:
        \begin{lstlisting}
            [HttpPost]
            [Authorize(Policy = "Administrator")]
            public IActionResult Create([FromBody] Organization organization, [FromHeader] string Authorization)
            {
                // Implementacion del metodo
            }

        \end{lstlisting}
        Solo los usuarios con el rol \texttt{ADMIN} pueden acceder a este método. El
        cliente debe enviar el token JWT en el encabezado de la solicitud
        \texttt{Authorization}, y el servidor verificará si el token es válido y
        contiene el rol necesario.
        \item Este método está protegido por la política \texttt{Director}:
        \begin{lstlisting}
            [HttpPut]
            [Authorize(Policy = "Director")]
            public IActionResult Update([FromQuery] int id, [FromQuery] string orgType, [FromQuery] string illness, [FromBody] Organization organization, [FromHeader] string Authorization)
            {
                // Implementacion del metodo
            }
        \end{lstlisting}
        Solo los usuarios con el rol \texttt{DIRECTOR} pueden acceder a este método. El
        cliente debe enviar el token JWT en el encabezado de la solicitud
        \texttt{Authorization}, y el servidor verificará si el token es válido y
        contiene el rol necesario.    
    \end{itemize}
    
\end{itemize}

Por tanto, el flujo de ejecución es el siguiente:
\begin{enumerate}
    \item \textbf{Login y Obtención del Token:}
    \begin{itemize}
        \item El cliente envía una solicitud de login con las credenciales del usuario.
        \item Si las credenciales son correctas, el servidor genera un token JWT que incluye información sobre el usuario y sus roles.
        \item El token se devuelve al cliente.
    \end{itemize}
    \item \textbf{Acceso a Métodos Protegidos:}
    \begin{itemize}
        \item Para acceder a métodos protegidos (Create, Update), el cliente debe incluir el token JWT en el encabezado Authorization de la solicitud, en formato Bearer <token>.
        \item El servidor extrae el token del encabezado y lo valida:
        \begin{itemize}
            \item Verifica la firma del token.
            \item Verifica la fecha de expiración del token.
            \item Verifica que el token contenga los roles necesarios según la política aplicada al método.
        \end{itemize}
        
        \item Si el token es válido y contiene los roles necesarios, el servidor permite el acceso al método.
        \item Si el token es inválido o no contiene los roles necesarios, el servidor devuelve un error de autorización (por ejemplo, 401 Unauthorized o 403 Forbidden).
    \end{itemize}
\end{enumerate}


\subsubsection{\textit{Azure SQL}}
\cite{AzureSQL}
\textit{Azure SQL Database} es un motor de base de datos de plataforma como servicio
(PaaS) totalmente administrado que se encarga de la mayoría de las funciones de
administración de bases de datos, incluidas \textit{la supervisión sin intervención del
usuario, la aplicación de revisiones, la creación de copias de seguridad y la
actualización}. El motor de base de datos de Azure SQL Server se ejecuta siempre
en la versión más reciente y estable del motor de base de datos de SQL Server,
así como en un sistema operativo revisado que tiene una disponibilidad del 99,99
\%. Las funcionalidades de PaaS en Azure SQL Database permiten concentrarse en
las actividades de administración y optimización de bases de datos específicas
del dominio que son importantes para el negocio.\\

El motor de base de datos más reciente de \textit{Microsoft SQL Server} es la base de
\textit{Azure SQL Database}, permitiendo utilizar características avanzadas de procesamiento de
consultas, como el procesamiento de consultas inteligente y las tecnologías de
memoria de alto rendimiento. De hecho, las últimas funcionalidades de SQL Server
se publican primero en Azure SQL Database y luego en SQL Server mismo. Las
funcionalidades más recientes de SQL Server se pueden obtener sin costo mediante
actualizaciones o revisiones, y se han probado en millones de bases de datos.


En cuanto a las opciones de implementación de base de datos de Azure SQL, podemos resaltar dos:
\begin{itemize}
    \item \textbf{Una base de datos única} es una base de datos aislada que se
    administra completamente. Si tiene aplicaciones y microservicios modernos en
    la nube que necesitan un solo origen de datos confiable, puede usar esta
    opción. Una sola base de datos es similar al motor de base de datos de SQL
    Server. Es la opción más sencilla para nuestro caso, sobre todo al principio
    del desarrollo.
    \item El \textbf{grupo elástico} es una colección de bases de datos distintas con un
    conjunto compartido de recursos, como la memoria o la CPU. Un grupo elástico
    puede permitir el movimiento de una sola base de datos. Éste no se ha implementado en esta aplicación, aunque 
\end{itemize}

\section{Sistema experto}
\cite{innovaciondigital360SistemasExpertos}
Los sistemas expertos, enmarcados en el campo de la Inteligencia Artificial
(IA), son programas informáticos que emulan la capacidad de una persona experta
en un dominio de conocimiento o área de actividad específica.
\\
Su evolución y historia se remontan a las décadas de 1960 y 1970, cuando los
pioneros en la IA, como Allen Newell y Herbert A. Simon, desarrollaron los
primeros sistemas de razonamiento basados en reglas. Estos sistemas se centraron
en la resolución de problemas mediante la aplicación de lógica inductiva y
deductiva.
\\
A medida que avanzaba el tiempo, los sistemas de conocimiento experimentaron un
crecimiento significativo en la década de 1980, con el desarrollo de
herramientas como MYCIN para el diagnóstico médico y Dendral para la
identificación de compuestos químicos. Esta era también vio la creación de
herramientas de desarrollo de sistemas expertos, como CLIPS. Sin embargo, a
medida que avanzaba la década de 1990, los sistemas expertos enfrentaron
desafíos debido a su dependencia en la representación de conocimiento y la
captura de reglas, lo que llevó a una mayor exploración de otras ramas de la IA,
como el aprendizaje automático. A pesar de esto, los sistemas expertos siguen
siendo una parte importante de la IA, y con la evolución tecnológica actual,
continúan desempeñando un papel relevante en la toma de decisiones automatizada.
\\
La tecnología subyacente que impulsa a los sistemas expertos se basa en varios conceptos fundamentales, entre los que se incluyen:
\begin{itemize}
    \item \textbf{Reglas Heurísticas:} Las reglas heurísticas son pautas o
    principios empíricos que guían el razonamiento humano. En los sistemas
    expertos, se utilizan reglas heurísticas para codificar el conocimiento de
    expertos en forma de \textit{si-entonces}. Por ejemplo, \textit{Si se han marcado 4
    evidencias en el indicador, el indicador se marca como conseguido.} Estas
    reglas permiten que el sistema experto tome decisiones basadas en la
    experiencia acumulada.
    \item \textbf{Lógica Difusa:} La lógica difusa es un enfoque que permite
    manejar la incertidumbre y la imprecisión en el razonamiento. A diferencia
    de la lógica binaria convencional (verdadero o falso), la lógica difusa
    permite representar grados de verdad. Esto es especialmente útil cuando se
    trata con conceptos vagos o subjetivos. Por ejemplo, en la obtención del
    nivel de la evaluación de indicadores, obtenemos cinco niveles a partir de
    la puntuación total, los cuales son: \textit{excelente, muy bueno, bueno,
    mejorable} y \textit{muy mejorable}, lo cual ayuda a determinar cómo de
    bien se ha cumplido la evaluación de indicadores, más allá de determinar si
    se ha cumplido o no la misma evaluación de indicadores.
    \item \textbf{Redes Bayesianas:} Las redes bayesianas son modelos
    probabilísticos que utilizan teoremas de probabilidad bayesiana para
    representar y actualizar la incertidumbre en un sistema. Son especialmente
    útiles cuando se deben tomar decisiones basadas en evidencia acumulada. Por
    ejemplo, en medicina, una red bayesiana puede ayudar a calcular la
    probabilidad de que un paciente tenga una enfermedad en función de múltiples
    factores, como síntomas, historial médico y resultados de pruebas.    
\end{itemize}
\imagen{./Figuras/Sistema experto/Figura-2-Estructura-de-un-Sistema-Experto.png}{Estructura de un sistema experto}{0.9}
La estructura básica de un sistema experto tiene los siguientes componentes:
\begin{itemize}
    \item \textbf{Usuario:} Es la persona o el sistema que interactúa con el sistema
    experto para obtener soluciones a problemas específicos. En nuestro caso se
    trata del administrador de \textit{Fundación Miradas}, quien se encarga de
    proporcionar los datos necesarios sobre las evidencias para que el sistema
    experto comience a trabajar.
    \item \textbf{Interfaz:} Es el medio por el cual el usuario interactúa con
    el sistema experto. En nuestro caso es la interfaz gráfica de la aplicación
    Android, lugar donde el administrador de \textit{Fundación Miradas} se
    encarga de señalar las evidencias que se cumplen de cada uno de los
    indicadores.
    \item \textbf{Motor de Inferencia:} Es el corazón del sistema experto.
    Utiliza las reglas y datos en la base de conocimientos para inferir
    conclusiones. También interactúa con la base de hechos.
    \item \textbf{Base de hechos:} Contiene datos o hechos específicos del
    problema actual que el usuario está tratando de resolver. En nuestro caso
    son por los registros de los indicadores y la evaluación de indicadores
    correspondiente, los cuales contienen toda la información necesaria para que
    sea proporcionada al motor de inferencia.
    \item \textbf{Base de Conocimiento:} Contiene el conocimiento experto en
    forma de hechos y reglas. Este conocimiento es generalmente adquirido de
    expertos humanos y codificado en una forma que el motor de inferencia puede
    utilizar. En nuestro caso contiene todo el conjunto de reglas sobre estado
    de los indicadores a partir del número de evidencias marcadas, si dichos
    indicadores requieren estar en el plan de mejora, la puntuación para cada
    combinación interés del indicador-estado del indicador y el nivel de
    puntuación de la evaluación de indicadores.
    \item \textbf{Sistema de Adquisición de Conocimiento:} Es el componente que
    facilita la adquisición de conocimiento de los expertos humanos y su
    incorporación a la base de conocimientos.
    \item \textbf{Subsistema de Justificación:} Proporciona explicaciones sobre
    cómo se llegó a una determinada conclusión o por qué se pide cierta
    información. Esto aumenta la confianza del usuario en las conclusiones del
    sistema.
    \item \textbf{Conocimiento Experto:} Es el conocimiento que los expertos
    humanos tienen sobre el dominio del problema. Este conocimiento es adquirido
    por el sistema de adquisición de conocimiento y almacenado en la base de
    conocimientos.
\end{itemize}


En nuestro caso, utilizaremos un \textbf{sistema basado en reglas (SBR)}, que son sistemas basados
en reglas clásicas bien conocidas por el mundo de la informática en la forma IF
(condición) y THEN (acción). Dado un conjunto de hechos, los sistemas de
conocimiento son capaces de deducir nuevos hechos gracias a sus reglas.

Por ejemplo, para nuestro caso con la evaluación de indicadores, se ha aplicado para el cálculo de resultados y para determinar el nivel de los mismos:
\begin{enumerate}
    \item Por un lado, se tiene que determinar qué indicadores necesitan estar incluidos en el plan de mejora y qué indicadores no necesitan estar en el plan de mejora, aplicando las reglas en dos fases:
    \begin{enumerate}
        \item En primer lugar, se comprueba para cada indicador el número de evidencias marcadas, teniendo las siguientes reglas para ello:
        \begin{itemize}
            \item \texttt{IF indicadorN.numEvidenciasCumplidas=0 \\OR\\ indicadorN.numEvidenciasCumplidas=1 \\THEN\\ indicadorN.estado=en\_comienzo}
            \item \texttt{IF indicadorN.numEvidenciasCumplidas=2 \\OR\\ indicadorN.numEvidenciasCumplidas=3 \\THEN\\ indicadorN.estado=en\_proceso}
            \item \texttt{IF indicadorN.numEvidenciasCumplidas=4 \\THEN\\ indicadorN.estado=conseguido}
        \end{itemize}
        \item Posteriormente, a partir del estado, determinamos si un indicador requiere o no requiere estar en el plan de mejora:
        \begin{itemize}
            \item \texttt{IF indicadorN.estado=en\_comienzo \\OR\\ indicadorN.estado=en\_proceso \\THEN\\ indicadorN.necesitaEstarEnPlanDeMejora=SI}
            \item \texttt{IF indicadorN.estado=conseguido \\THEN\\ indicadorN.necesitaEstarEnPlanDeMejora=NO}
        \end{itemize}
    \end{enumerate} 
    \item Por otro lado, a partir de los resultados se determina la puntuación para cada combinación de interés y de estado de indicador, y a partir de ahí obtener el nivel:
    \begin{enumerate}
        \item En primer lugar obtenemos el valor del indicador para añadirlo a
        la suma total y de paso para calcular la puntuación para cada
        combinación de interés y de estado de indicador:
        \begin{itemize}
            \item \texttt{IF indicadorN.estado=conseguido \\AND\\ indicadorN.interes=interes\_fundamental \\THEN\\ indicadorN.valor=5}
            \item \texttt{IF indicadorN.estado=en\_proceso \\AND\\ indicadorN.interes=interes\_fundamental \\THEN\\ indicadorN.valor=4}
            \item \texttt{IF indicadorN.estado=conseguido \\AND\\ indicadorN.interes=interes\_alto \\THEN\\ indicadorN.valor=4}
            \item \texttt{IF indicadorN.estado=en\_proceso \\AND\\ indicadorN.interes=interes\_alto \\THEN\\ indicadorN.valor=3}
            \item \texttt{IF indicadorN.estado=conseguido \\AND\\ indicadorN.interes=interes\_medio \\THEN\\ indicadorN.valor=3}
            \item \texttt{IF indicadorN.estado=en\_proceso \\AND\\ indicadorN.interes=interes\_medio \\THEN\\ indicadorN.valor=2}
            \item \texttt{IF indicadorN.estado=conseguido \\AND\\ indicadorN.interes=interes\_bajo \\THEN\\ indicadorN.valor=2}
            \item \texttt{IF indicadorN.estado=en\_proceso \\AND\\ indicadorN.interes=interes\_bajo \\THEN\\ indicadorN.valor=1}
        \end{itemize}
        \item Posteriormente, a partir del tipo de evaluación y de la puntuación total, se obtiene un nivel del test de indicadores:
        \begin{itemize}
            \item \texttt{IF testIndicadores.tipo=completo \\AND\\ testIndicadores.puntuacion>=200 \\OR\\ testIndicadores.puntuacion<=250 \\THEN\\ testIndicadores.nivel=excelente}
            \item \texttt{IF testIndicadores.tipo=completo \\AND\\ testIndicadores.puntuacion>=150 \\OR\\ testIndicadores.puntuacion<=200 \\THEN\\ testIndicadores.nivel=muy\_bueno}
            \item \texttt{IF testIndicadores.tipo=completo \\AND\\ testIndicadores.puntuacion>=100 \\OR\\ testIndicadores.puntuacion<=150 \\THEN\\ testIndicadores.nivel=bueno}
            \item \texttt{IF testIndicadores.tipo=completo \\AND\\ testIndicadores.puntuacion>=50 \\OR\\ testIndicadores.puntuacion<=100 \\THEN\\ testIndicadores.nivel=mejorable}
            \item \texttt{IF testIndicadores.tipo=completo \\AND\\ testIndicadores.puntuacion>=0 \\OR\\ testIndicadores.puntuacion<=50 \\THEN\\ testIndicadores.nivel=muy\_mejorable}
            \item \texttt{IF testIndicadores.tipo=simple \\AND\\ testIndicadores.puntuacion>=118 \\OR\\ testIndicadores.puntuacion<=143 \\THEN\\ testIndicadores.nivel=excelente}
            \item \texttt{IF testIndicadores.tipo=simple \\AND\\ testIndicadores.puntuacion>=89 \\OR\\ testIndicadores.puntuacion<=118 \\THEN\\ testIndicadores.nivel=muy\_bueno}
            \item \texttt{IF testIndicadores.tipo=simple \\AND\\ testIndicadores.puntuacion>=60 \\OR\\ testIndicadores.puntuacion<=88 \\THEN\\ testIndicadores.nivel=bueno}
            \item \texttt{IF testIndicadores.tipo=simple \\AND\\ testIndicadores.puntuacion>=30 \\OR\\ testIndicadores.puntuacion<=59 \\THEN\\ testIndicadores.nivel=mejorable}
            \item \texttt{IF testIndicadores.tipo=simple \\AND\\ testIndicadores.puntuacion>=0 \\OR\\ testIndicadores.puntuacion<=29 \\THEN\\ testIndicadores.nivel=muy\_mejorable}
        \end{itemize}
    \end{enumerate} 
    
\end{enumerate}

Para poder programar el sistema experto, se utilizó \texttt{NRules} en el lado del servidor.

\subsection{NRules}
\texttt{NRules} es un motor de reglas de código abierto para .NET que se basa en el
algoritmo de coincidencia Rete. Las reglas se crean en C\# mediante DSL interno.\cite{nrulesRulesEngine}
\\
NRules también es un motor de inferencia donde, a diferencia de los motores de
secuencias de comandos, no existe un orden predefinido en el que se ejecutan las
reglas. En cambio, el motor de inferencia determina qué reglas deben activarse
en función de los hechos que se le proporcionan y luego las ejecuta de acuerdo
con un algoritmo de resolución de conflictos. Entre otras características,
NRules admite encadenamiento directo, consultas de hechos complejos y
cuantificadores negativos, existenciales y universales.\cite{nrulesRulesEngine}
\\
Antes de nada, debemos añadir el paquete de nuget de la siguiente manera:\cite{nrulesRulesEngine}
\begin{lstlisting}
    dotnet add package NRules
\end{lstlisting}

El uso básico de NRules se resume en diferentes pasos:\cite{nrulesGettingStarted}
\begin{itemize}
    \item En primer lugar, debemos crear diferentes modelos, algo que ya tenemos
    hecho. NRules sugiere en su documentación como comienzo crear una clase
    \texttt{Customer} y una clase llamada \texttt{Order}:\cite{nrulesGettingStarted}
    \begin{lstlisting}
        public class Customer
        {
            public string Name { get; }
            public bool IsPreferred { get; set; }

            public Customer(string name)
            {
                Name = name;
            }

            public void NotifyAboutDiscount()
            {
                Console.WriteLine($"Customer {Name} was notified about a discount");
            }
        }

        public class Order
        {
            public int Id { get; }
            public Customer Customer { get; }
            public int Quantity { get; }
            public double UnitPrice { get; }
            public double PercentDiscount { get; set; }
            public bool IsOpen { get; set; } = true;

            public Order(int id, Customer customer, int quantity, double unitPrice)
            {
                Id = id;
                Customer = customer;
                Quantity = quantity;
                UnitPrice = unitPrice;
            }
        }
    \end{lstlisting}
    \item Posteriormente, con estos modelos, se crean diferentes reglas. Por
    ejemplo, una regla que determina que si en caso de que un cliente es
    preferente se le asigna un descuento del 10\%:\cite{nrulesGettingStarted}
    \begin{lstlisting}
        public class PreferredCustomerDiscountRule : Rule
        {
            public override void Define()
            {
                Customer customer = default;
                IEnumerable<Order> orders = default;

                When()
                    .Match<Customer>(() => customer, c => c.IsPreferred)
                    .Query(() => orders, x => x
                        .Match<Order>(
                            o => o.Customer == customer,
                            o => o.IsOpen,
                            o => o.PercentDiscount == 0.0)
                        .Collect()
                        .Where(c => c.Any()));

                Then()
                    .Do(ctx => ApplyDiscount(orders, 10.0))
                    .Do(ctx => ctx.UpdateAll(orders));
            }

            private static void ApplyDiscount(IEnumerable<Order> orders, double discount)
            {
                foreach (var order in orders)
                {
                    order.PercentDiscount = discount;
                }
            }
        }
    \end{lstlisting}
    Tras aplicar el descuento, se envía la etiqueta con que el descuento ha sido aplicado:
    \begin{lstlisting}
        public class DiscountNotificationRule : Rule
        {
            public override void Define()
            {
                Customer customer = default;

                When()
                    .Match<Customer>(() => customer)
                    .Exists<Order>(o => o.Customer == customer, o => o.PercentDiscount > 0.0);

                Then()
                    .Do(_ => customer.NotifyAboutDiscount());
            }
        }
    \end{lstlisting}
    \item Por último, se cargan las reglas según se desea en el repositorio de
    reglas, se compilan, se crea una sesión de trabajo y se insertan los objetos
    a la base de hechos, para luego lanzar las reglas.\cite{nrulesGettingStarted}
    \begin{lstlisting}
        //Cargamos las reglas
        var repository = new RuleRepository();
        repository.Load(x => x.From(typeof(PreferredCustomerDiscountRule).Assembly));

        //Compilamos las reglas
        var factory = repository.Compile();

        //Creamos la sesion
        var session = factory.CreateSession();

        //Creamos los modelos
        var customer = new Customer("John Doe") {IsPreferred = true};
        var order1 = new Order(123456, customer, 2, 25.0);
        var order2 = new Order(123457, customer, 1, 100.0);

        //Insertamos los hechos a la base de hechos
        session.Insert(customer);
        session.Insert(order1);
        session.Insert(order2);

        //Lanzamos las reglas
        session.Fire();
    \end{lstlisting}
\end{itemize}
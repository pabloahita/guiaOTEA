\apendice{Especificación de diseño}

\section{Introducción}

\section{Diseño de datos}
%Clases
En cuanto al diseño de los datos, se han utilizado las siguientes clases o entidades, que son idénticas tanto en la base de datos, como en el servidor, como en el cliente:
\begin{itemize}
    
    \imagen{./Figuras/Diagramas/paqueteUser.png}{Paquete \texttt{user}}
    \item \textbf{User}: Esta entidad se encarga de almacenar información sobre los usuarios registrados en la base de datos. Dicha entidad consta de los siguientes campos:
    \begin{itemize}
        \item \texttt{emailUser}: Almacena la dirección de correo electrónico del usuario. Es de tipo \texttt{String} o \texttt{VARCHAR(500)}
        \item \texttt{userType}: Indica el tipo de usuario, que puede ser \texttt{ADMIN} o \texttt{ORGANIZATION}.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}
        \item \texttt{passwordUser}: Almacena la contraseña del usuario. Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{first\_name}: Almacena el nombre del usuario. Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{last\_name}: Almacena el apellido del usuario. Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{telephone}: Almacena el número de teléfono del usuario. Es de tipo \texttt{long} o \texttt{BIGINT}
        \item \texttt{idOrganization}: Almacena el identificador de la organización a la
        que pertenece el usuario.En caso de que
        \texttt{userType=ADMIN}, ese valor es un nulo representado tanto en
        cliente como en servidor como -1. Es de tipo \texttt{INT}
        \item \texttt{organizationType}: Indica el tipo de la organización, que
        puede ser "EVALUATED" o "EVALUATOR". En caso de que
        \texttt{userType=ADMIN}, ese valor es un nulo representado tanto en
        cliente como en servidor como "-". Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con
        la organización.En caso de que
        \texttt{userType=ADMIN}, ese valor es un nulo representado tanto en
        cliente como en servidor como "-". Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{PRIMARY KEY}: La clave primaria de esta tabla es el campo "emailUser", considerando que no se pueden añadir dos emails iguales.
        \item \texttt{CHECK}: Define una serie de condiciones que los datos deben cumplir para ser válidos, comprobando léxicamente la clave primaria.
      \end{itemize}

      \item \textbf{City: }Esta entidad se utiliza como carga de las ciudades españolas, utilizando para ello los siguientes campos:
      \begin{itemize}
        \item \texttt{idCity: }Es el identificador de la ciudad. Es de tipo \texttt{INT}.
        \item \texttt{idProvince: }Es el identificador de la provincia a la que pertenece la ciudad. Es de tipo \texttt{INT}.
        \item \texttt{idRegion: }Es el identificador de la región o comunidad autónoma a la que pertenece la ciudad. Es de tipo \texttt{INT}.
        \item \texttt{idCountry: }Es el identificador del país al que pertenece la ciudad. Es de tipo \texttt{String} o \texttt{VARCHAR(50)}
        \item \texttt{cityName: }Es el nombre de la ciudad.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}
        \item \texttt{PRIMARY KEY}: La clave primaria está conformada por las columnas \texttt{idCity, idProvince, idRegion e idCountry}.
        \item \texttt{FOREIGN KEY}: Los campos \texttt{idProvince, idRegion e idCountry} establecen una relación directa con la entidad \textbf{Province}.
      \end{itemize}
    
      \item \textbf{Province: }:Esta entidad se utiliza como carga de las provincias españolas, utilizando para ello los siguientes campos:
      \begin{itemize}
        \item \texttt{idProvince}: Almacena el identificador de la provincia. Es de tipo \texttt{INT}.
        \item \texttt{idRegion}: Almacena el identificador de la región a la que pertenece la provincia.Es de tipo \texttt{INT}.
        \item \texttt{idCountry}: Almacena el identificador del país al que pertenece la provincia. Es de tipo \texttt{String} o \texttt{VARCHAR(50)}
        \item \texttt{nameProvince}: Almacena el nombre de la provincia. Es de tipo \texttt{String} o \texttt{VARCHAR(500)}
        \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{idProvince}, \texttt{idRegion} e \texttt{idCountry}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la tabla "regions" a través de los campos \texttt{idRegion} e \texttt{idCountry}.
      \end{itemize}
    \item \textbf{Region: }Esta entidad se utiliza como carga de las comunidades autónomas españolas, utilizando para ello los siguientes campos:
    \begin{itemize}
      \item \texttt{idRegion}: Almacena el identificador de la región.Es de tipo \texttt{INT}.
      \item \texttt{idCountry}: Almacena el identificador del país al que pertenece la región. Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
      \item \texttt{nameRegion}: Almacena el nombre de la región.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
      \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{idRegion} e \texttt{idCountry}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Country} a través del campo \texttt{idCountry}.
    \end{itemize}
    \item \textbf{Country: }Esta entidad se utiliza como carga de las ciudades españolas, utilizando para ello los siguientes campos:
    \begin{itemize}
      \item \texttt{idCountry: }Es el identificador del país. Es de tipo \texttt{String} o VARCHAR(500).
      \item \texttt{nameEnglish: }Es el nombre del país en inglés. Es de tipo \texttt(String) o \texttt{VARCHAR(500)}.
      \item \texttt{nameSpanish: }Es el nombre del país en español. Es de tipo \texttt(String) o \texttt{VARCHAR(500)}. 
      \item \texttt{nameFrench: }Es el nombre del país en inglés. Es de tipo \texttt(String) o \texttt{VARCHAR(500)}.
      \item \texttt{PRIMARY KEY: }La clave primaria de esta entidad es el campo \texttt{idCountry}
    \end{itemize}
    \item \textbf{Address: }:Esta entidad se utiliza para almacenar información sobre las diferentes direcciones que se almacenan para organizaciones y centros, utilizando para ello los siguientes campos:
        \begin{itemize}
        \item \texttt{idAddress}: Almacena el identificador de la dirección. Es de tipo \texttt{INT}.
        \item \texttt{addressName}: Almacena el nombre de la dirección.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{zipCode}: Almacena el código postal de la dirección.Es de tipo \texttt{INT}.
        \item \texttt{idCity}: Almacena el identificador de la ciudad.Es de tipo \texttt{INT}.
        \item \texttt{idProvince}: Almacena el identificador de la provincia.Es de tipo \texttt{INT}.
        \item \texttt{idRegion}: Almacena el identificador de la región.Es de tipo \texttt{INT}.
        \item \texttt{idCountry}: Almacena el identificador del país al que pertenece la dirección.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{nameCity}: Almacena el nombre de la ciudad (solo para ciudades fuera de España).Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{nameProvince}: Almacena el nombre de la provincia (solo para provincias fuera de España).Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{nameRegion}: Almacena el nombre de la región (solo para regiones fuera de España).Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{PRIMARY KEY: }La clave primaria de esta entidad es el campo \texttt{idAddress}
        \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Country} a través del campo \texttt{idCountry}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{City} a través de los campos \texttt{idCity}, \texttt{idProvince}, \texttt{idRegion} e \texttt{idCountry} (solo si es una ciudad española).
        \end{itemize}

        \imagen{./Figuras/Diagramas/paqueteOrganization.png}{Paquete \texttt{organization}}
    \item \textbf{Organization}: Esta tabla se encarga de almacenar la información sobre las organizaciones registradas de todos los tipos, utilizando para ello los siguientes campos:
        \begin{itemize}
        \item \texttt{IdOrganization}: Almacena el identificador de la organización. Es de tipo \texttt{INT}.
        \item \texttt{orgType}: Indica el tipo de la organización. Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con la organización. Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{nameOrg}: Almacena el nombre de la organización.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{idAddress}: Almacena el identificador de la dirección de la organización.Es de tipo \texttt{INT}.
        \item \texttt{email}: Almacena la dirección de correo electrónico de la organización.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{telephone}: Almacena el número de teléfono de la organización.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{information}: Almacena información sobre la organización.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{emailOrgPrincipal}: Almacena la dirección de correo electrónico del usuario principal de la organización.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{IdOrganization}, \texttt{orgType} e \texttt{illness}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Address} a través del campo \texttt{idAddress}.
        \end{itemize}
        :
\imagen{./Figuras/Diagramas/paqueteIndicator.png}{Paquete \texttt{indicator}}

    \item \textbf{Indicator}: Esta tabla se encarga de almacenar información sobre los indicadores almacenados en la base de datos, utilizando para ello los siguientes campos:
        \begin{itemize}
        \item \texttt{indicatorId}: Almacena el identificador del indicador. Es de tipo \texttt{INT}.
        \item \texttt{indicatorType}: Indica el tipo de indicador.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{descriptionEnglish}: Almacena la descripción en inglés del indicador.Es de tipo \texttt{String} o \texttt{VARCHAR(5000)}.
        \item \texttt{descriptionSpanish}: Almacena la descripción en español del indicador.Es de tipo \texttt{String} o \texttt{VARCHAR(5000)}.
        \item \texttt{descriptionFrench}: Almacena la descripción en francés del indicador.Es de tipo \texttt{String} o \texttt{VARCHAR(5000)}.
        \item \texttt{indicatorPriority}: Almacena la prioridad del indicador. Es de tipo \texttt{INT}.
        \item \texttt{indicatorVersion}: Almacena la versión del indicador. Es de tipo \texttt{INT}.
        \item \texttt{isActive}: Indica si el indicador está en uso o no. Es de tipo \texttt{INT}.
        \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{indicatorId}, \texttt{indicatorType} e \texttt{indicatorVersion}.
        \end{itemize}

    \item \textbf{Evidence}: Esta entidad se encarga de almacenar información sobre todas las evidencias de cada uno de los indicadores, utilizando para ello los siguientes campos:
        \begin{itemize}
        \item \texttt{idEvidence}: Almacena el identificador de la evidencia. Es de tipo \texttt{INT}.
        \item \texttt{idIndicator}: Almacena el identificador del indicador al que pertenece la evidencia. Es de tipo \texttt{INT}.
        \item \texttt{indicatorType}: Indica el tipo de indicador.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{descriptionEnglish}: Almacena la descripción en inglés de la evidencia.Es de tipo \texttt{String} o \texttt{VARCHAR(5000)}.
        \item \texttt{descriptionSpanish}: Almacena la descripción en español de la evidencia.Es de tipo \texttt{String} o \texttt{VARCHAR(5000)}.
        \item \texttt{descriptionFrench}: Almacena la descripción en francés de la evidencia.Es de tipo \texttt{String} o \texttt{VARCHAR(5000)}.
        \item \texttt{evidenceValue}: Almacena el valor de la evidencia. Es de tipo \texttt{INT}.
        \item \texttt{indicatorVersion}: Almacena la versión del indicador. Es de tipo \texttt{INT}.
        \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{idEvidence}, \texttt{idIndicator}, \texttt{indicatorType} e \texttt{indicatorVersion}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Indicator} a través de los campos \texttt{idIndicator}, \texttt{indicatorType} e \texttt{indicatorVersion}.
        \end{itemize}
        
\imagen{./Figuras/Diagramas/paqueteOrgData.png}{Paquete \texttt{orgData}}

    \item \textbf{Center}: Esta entidad se encarga de almacenar los centros de la diferentes organizaciones que tiene cada organización, utilizando para ello las siguientes columnas:
        \begin{itemize}
        \item \texttt{IdOrganization}: Almacena el identificador de la organización. Es de tipo \texttt{INT}.
        \item \texttt{orgType}: Indica el tipo de la organización del centro.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con la organización del centro.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{idCenter}: Almacena el identificador del centro.Es de tipo \texttt{INT}.
        \item \texttt{centerDescription}: Almacena la descripción del centro.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{idAddress}: Almacena el identificador de la dirección del centro.Es de tipo \texttt{INT}.
        \item \texttt{telephone}: Almacena el número de teléfono del centro.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{IdOrganization}, \texttt{orgType}, \texttt{illness} e \texttt{idCenter}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Organization} a través de los campos \texttt{IdOrganization}, \texttt{orgType} e \texttt{illness}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la tabla \textbf{Address} a través del campo \texttt{idAddress}.
        \end{itemize}

    \item \textbf{EvaluatorTeam}: Esta entidad se encarga de almacenar información sobre los equipos evaluadores, utilizando para ello los siguientes campos:
        \begin{itemize}
        \item \texttt{idEvaluatorTeam}: Almacena el identificador del equipo evaluador.Es de tipo \texttt{INT}.
        \item \texttt{creationDate}: Almacena la fecha de creación del equipo.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{emailConsultant}: Almacena la dirección de correo electrónico del consultor del equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{emailResponsible}: Almacena la dirección de correo electrónico del responsable del equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{emailProfessional}: Almacena la dirección de correo electrónico del profesional del equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{idOrganization}: Almacena el identificador de la organización a la que pertenece el equipo.Es de tipo \texttt{INT}.
        \item \texttt{orgType}: Indica el tipo de la organización del equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con la organización del equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
        \item \texttt{patientName}: Almacena el nombre del paciente evaluado por el equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{relativeName}: Almacena el nombre del familiar del paciente evaluado por el equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
        \item \texttt{evaluationDate1}: Almacena la primera fecha de evaluación.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{evaluationDate2}: Almacenala segunda fecha de evaluación.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{evaluationDate3}: Almacena la tercera fecha de evaluación.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{evaluationDate4}: Almacena la cuarta fecha de evaluación.Es de tipo \texttt{long} o \texttt{BIGINT}.
        \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por el campo \texttt{idEvaluatorTeam}.
        \item \texttt{FOREIGN KEY}: Establece una relación con la tabla \textbf{Organization} a través de los campos \texttt{idOrganization}, \texttt{orgType} e \texttt{illness}.
        \end{itemize}
    \item \textbf{EvaluatorTeamMember}: Esta entidad se encarga de registrar aquellos usuarios que pertenezcan a equipos evaluadores, utilizando para ello los siguientes campos:
    \begin{itemize}
      \item \texttt{emailUser}: Almacena la dirección de correo electrónico del miembro del equipo.Es de tipo \texttt{String} o \texttt{VARCHAR(500)}.
      \item \texttt{idEvaluatorTeam}: Almacena el identificador del equipo evaluador al que pertenece el miembro.Es de tipo \texttt{INT}.
      \item \texttt{idEvaluatorOrganization}: Almacena el identificador de la organización evaluadora del miembro.Es de tipo \texttt{INT}.
      \item \texttt{orgType}: Indica el tipo de la organización del miembro.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
      \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con la organización del miembro.Es de tipo \texttt{String} o \texttt{VARCHAR(50)}.
      \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{emailUser}, \texttt{idEvaluatorTeam}, \texttt{idEvaluatorOrganization}, \texttt{orgType} e \texttt{illness}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{User} a través del campo \texttt{emailUser}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{EvaluatorTeam} a través de los campos \texttt{idEvaluatorTeam}, \texttt{idOrganization}, \texttt{orgType} e \texttt{illness}.
    \end{itemize}
    \item \textbf{IndicatorsEvaluation}: Esta entidad se encarga de almacenar la información sobre los diferentes test de indicadores, utilizando para ello los siguientes campos:
    \begin{itemize}
      \item \texttt{evaluationDate}: Almacena la fecha de evaluación de los indicadores.Es de tipo \texttt{long} o \texttt{BIGINT}.
      \item \texttt{idEvaluatedOrganization}: Almacena el identificador de la organización evaluada.Es de tipo \texttt{INT}.
      \item \texttt{orgTypeEvaluated}: Indica el tipo de la organización evaluada.Es de tipo \texttt{String} o de tipo
      \item \texttt{idEvaluatorTeam}: Almacena el identificador del equipo evaluador que realizó la evaluación.Es de tipo \texttt{INT}.
      \item \texttt{idEvaluatorOrganization}: Almacena el identificador de la organización a la que pertenece el equipo evaluador.Es de tipo \texttt{INT}.
      \item \texttt{orgTypeEvaluator}: Indica el tipo de la organización del equipo evaluador.
      \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con la organización evaluada.
      \item \texttt{scoreLevel1}: Almacena el puntaje para el nivel 1 de los indicadores.Es de tipo \texttt{INT}.
      \item \texttt{scoreLevel2}: Almacena el puntaje para el nivel 2 de los indicadores.Es de tipo \texttt{INT}.
      \item \texttt{scoreLevel3}: Almacena el puntaje para el nivel 3 de los indicadores.Es de tipo \texttt{INT}.
      \item \texttt{scoreLevel4}: Almacena el puntaje para el nivel 4 de los indicadores.Es de tipo \texttt{INT}.
      \item \texttt{scoreLevel5}: Almacena el puntaje para el nivel 5 de los indicadores.Es de tipo \texttt{INT}.
      \item \texttt{scoreLevel6}: Almacena el puntaje para el nivel 6 de los indicadores.Es de tipo \texttt{INT}.
      \item \texttt{totalScore}: Almacena el puntaje total de la evaluación. Es de tipo \texttt{INT}.
      \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{evaluationDate}, \texttt{idEvaluatedOrganization}, \texttt{orgTypeEvaluated} e \texttt{illness}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Organization} a través de los campos \texttt{idEvaluatedOrganization}, \texttt{orgTypeEvaluated} e \texttt{illness}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{EvaluatorTeam} a través de los campos \texttt{idEvaluatorTeam}, \texttt{idEvaluatorOrganization}, \texttt{orgTypeEvaluator} e \texttt{illness}.
    \end{itemize}
    \item \textbf{IndicatorsEvaluationReg}: Esta entidad se encarga de almacenar los registros de cada uno de los test de indicadores realizados, existiendo uno para cada evidencia rellenada, utilizando para ello los siguientes campos:
    \begin{itemize}
      \item \texttt{evaluationDate}: Almacena la fecha de la evaluación de los indicadores.
      \item \texttt{idEvaluatedOrganization}: Almacena el identificador de la organización evaluada.Es de tipo \texttt{INT}.
      \item \texttt{orgTypeEvaluated}: Indica el tipo de la organización evaluada.
      \item \texttt{illness}: Almacena el tipo de enfermedad relacionada con la organización evaluada.
      \item \texttt{indicatorId}: Almacena el identificador del indicador evaluado. Es de tipo \texttt{INT}.
      \item \texttt{idEvidence}: Almacena el identificador de la evidencia relacionada con el indicador.Es de tipo \texttt{INT}.
      \item \texttt{isMarked}: Es un campo entero no nulo que indica si el indicador está marcado o no. Solo puede tener valores 0 o 1, lo que se verifica con una restricción \texttt{CHECK}.Es de tipo \texttt{INT}.
      \item \texttt{indicatorVersion}: Almacena la versión del indicador evaluado. Es de tipo \texttt{INT}.
      \item \texttt{PRIMARY KEY}: La clave principal de esta tabla está compuesta por los campos \texttt{evaluationDate}, \texttt{idEvaluatedOrganization}, \texttt{orgTypeEvaluated}, \texttt{illness}, \texttt{indicatorId}, \texttt{idEvidence} e \texttt{indicatorVersion}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Indicator} a través del campo \texttt{indicatorId}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{Evidence} a través del campo \texttt{idEvidence}.
      \item \texttt{FOREIGN KEY}: Establece una relación con la entidad \textbf{IndicatorsEvaluation} a través de los campos \texttt{evaluationDate}, \texttt{idEvaluatedOrganization}, \texttt{orgTypeEvaluated}, \texttt{illness} e \texttt{indicatorVersion}.
    \end{itemize}
\end{itemize}
\section{Diseño procedimental}
%Algoritmos
En cuanto al diseño procedimental de la aplicación, se tiene que tener en cuenta
qué se espera de cada una de las características que tiene la aplicación. El
objetivo fundamental de realizar este tipo de diseño es saber los pasos a seguir
para realizar cada una de las funcionalidades más importantes para cada uno de
los algoritmos a seguir. Para realizar el diseño procedimental se ha establecido
como base la realización de simples diagramas de flujo, que indiquen cómo tiene
que realizarse paso a paso estos algoritmos. No se requieren de algoritmos
bastante sofisticados para la realización de esta aplicación, por lo que se
antoja bastante más sencillo conocer los pasos a seguir. En nuestro caso,
tenemos varias funcionalidades diferentes:
\begin{itemize}
    \item \textbf{Iniciar sesión}: Para el inicio de sesión se ha decidido implementar este diagrama de flujo:
    \imagen{./Figuras/Diagramas/iniciarSesion.png}{Diagrama de flujo para el inicio de sesión}
    En este caso se inicializa con la introducción de los campos de usuario y de
    contraseña. Posteriormente, tras el intento de inicio de sesión, se intenta
    buscar el usuario con las credenciales de la base de datos. En primer lugar
    busca si el email está correctamente introducido, en caso de que el email no
    esté bien introducido, lanza el error y vuelve a empezar. En caso contrario,
    comprueba la contraseña. Si no es correcta, lanza el error y vuelve a
    empezar, y en caso contrario se consigue un inicio de sesión satisfactorio.
    \item \textbf{Registrar usuario}: Para el registro de usuario se ha decidido implementar este diagrama de flujo:
    \imagen{./Figuras/Diagramas/registrarUser.png}{Diagrama de flujo para el registro del usuario}
    Al igual que en el caso anterior, la dinámica es muy similar, con la
    diferencia que se necesitan introducir más campos de forma obligatoria.  En primer
    lugar se comprueba si se ha introducido el nombre del usuario. Si no se ha
    introducido vuelve al punto de arranque y en caso contrario pasa a comprobar
    el apellido. En caso de que no se haya introducido ningún apellido vuelve al
    punto de arranque y en caso contrario pasa a comprobar la organización. En
    caso de que no se haya introducido ninguna organización vuelve al punto de
    arranque y en caso contrario pasa a comprobar el email. Si no se ha
    introducido el email vuelve al punto de arranque y en caso contrario pasa a
    comprobar la contraseña. Si no se ha introducido la contraseña vuelve al
    punto de arranque y en caso contrario pasa a comprobar el teléfono. Si no se
    ha introducido ningún teléfono, vuelve al punto de arranque y en caso
    contrario se considera el registro del usuario como realizado.
    \item \textbf{Registrar organización}: Para el registro de la organización se cumple la misma dinámica que en la actividad anterior. Cabe
    resaltar que el campo de \textit{información} no se ha introducido en este
    diagrama debido a que no es un campo que se considere de obligatorio
    rellenado, más allá que para comentar algún elemento adicional. Se ha seguido el siguiente diagrama de flujo:
    \imagen{./Figuras/Diagramas/registrarOrg.png}{Diagrama de flujo para el registro de la organización}
    Como se puede apreciar, en primer lugar se comprueba si se ha introducido el
    nombre de la organización. Si no se ha introducido vuelve al punto de
    arranque y en caso contrario pasa a comprobar la dirección. En caso de que
    no se haya introducido ninguna dirección vuelve al punto de arranque y en
    caso contrario pasa a comprobar el código postal. En caso de que no se haya
    introducido ningún código postal vuelve al punto de arranque y en caso
    contrario pasa a comprobar la ciudad. Si no se ha introducido ninguna ciudad
    vuelve al punto de arranque y en caso contrario pasa a comprobar el email.
    Si no se ha introducido el email vuelve al punto de arranque y en caso
    contrario pasa a comprobar el teléfono. Si no se ha introducido ningún
    teléfono, vuelve al punto de arranque y en caso contrario se pasa a
    comprobar el director de la organización. Si no se ha introducido ningún
    director, se vuelve al punto de arranque y en caso contrario, se considera
    el registro de la organización como realizado.
    \item \textbf{Registrar equipo evaluador}: Para el registro del equipo evaluador se sigue una dinámica muy similar al del caso anterior, siguiendo para ello el siguiente diagrama de flujo:
    \imagen{./Figuras/Diagramas/registrarEvalTeam.png}{Diagrama de flujo para el registro del equipo evaluador}
    Como se puede apreciar, tras la introducción del consultor externo, el
    responsable, el profesional de atención directa, las fechas de evaluación,
    la fecha de creación, el nombre de la persona con TEA y el nombre de su
    familiar, se busca realizar la comprobación de dichos campos. En primer
    lugar si no se ha introducido un consultor externo vuelve al punto de
    arranque y en caso contrario comprueba el responsable. Si no se ha
    introducido ningún responsable, se vuelve al punto de arranque y en caso
    contrario se pasa a comprobar el profesional de atención directa. Si no se
    ha introducido ningún profesional de atención directa, se vuelve al punto de
    arranque y en caso contrario se pasan a comprobar las fechas de evaluación y
    de creación del equipo evaluador. Si no se ha introducido alguna de esas
    fechas, se vuelve al punto de arranque y en caso contrario se pasa a
    comprobar los nombres tanto de la persona con TEA como el de su familiar. En
    caso de que no se haya introducido alguno de los nombres, se vuelve al punto
    de arranque y en caso contrario se considera como registrado el equipo
    evaluador.
    \item \textbf{Realizar test de indicadores: }La realización del test de indicadores básica se considera como un proceso iterativo, el cual sigue el siguiente diagrama de flujo:
    \imagen{./Figuras/Diagramas/hacerTestIndicadores.png}{Diagrama de flujo para la realización del test de indicadores}.
    Como se puede comprobar, tras la obtención de los indicadores y evidencias con sus respectivos contadores, ambos se van actualizando a medida que se van avanzando en los test de indicadores. Si se ha superado el número de evidencias, refresca el número del indicador y retorna al valor 1 como valor de evidencia. En caso contrario ya habríamos terminado con el test y se obtendrían los resultados.

\end{itemize}
\section{Diseño arquitectónico}
% patrones de diseño, comunicacion, persistencia, requisitos,....
Como se ha mencionado con anterioridad, la arquitectura utilizada para el desarrollo de esta aplicación es una arquitectura de tipo \textit{Modelo-Vista-Controlador}:
\begin{itemize}
    \item En el lado del servidor tenemos tres tipos de clase diferentes segregadas por el paquete al que pertenecen. Dichos paquetes son:
    \begin{itemize}
        \item \textbf{Models: }Este paquete incluye todos los modelos de las clases que son incluidos en el servidor. Ejemplo: \begin{lstlisting}
            using Newtonsoft.Json;

namespace OTEAServer.Models
{
    public class Indicator
    {
        public Indicator(int idIndicator, string indicatorType, string descriptionEnglish, string descriptionSpanish, string descriptionFrench, int indicatorPriority, int indicatorVersion) {
            this.indicatorId = idIndicator;
            this.indicatorType = indicatorType;
            this.descriptionEnglish = descriptionEnglish;
            this.descriptionSpanish = descriptionSpanish;
            this.descriptionFrench = descriptionFrench;
            this.indicatorPriority = indicatorPriority;
            this.indicatorVersion = indicatorVersion;
        }


        [JsonProperty("indicatorId")]
        public int indicatorId { get; set; }

        [JsonProperty("indicatorType")]
        public string indicatorType { get; set; }

        [JsonProperty("descriptionEnglish")]
        public string descriptionEnglish { get; set; }
        
        [JsonProperty("descriptionSpanish")]
        public string descriptionSpanish { get; set; }
        
        [JsonProperty("descriptionFrench")]
        public string descriptionFrench { get; set; }

        [JsonProperty("indicatorPriority")]
        public int indicatorPriority { get; set; }

        [JsonProperty("indicatorVersion")]
        public int indicatorVersion { get; set; }
    }
}
        \end{lstlisting}
        Como se comprueba en el siguiente ejemplo, todos los campos del modelo
        de la clase \texttt{Indicator} tienen la propiedad de
        \textit{Newtonsoft.Json} denominada \texttt{JsonProperty}, la cual se
        utiliza para la serialización de los datos de este tipo para enviarlos
        en formato JSON.
        \item \textbf{Controllers: }Este paquete incluye todas las clases que estructuran los endpoints de la web app, utilizándose para realizar las operaciones en el servidor. Ejemplo:
        \begin{lstlisting}
            using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using OTEAServer.Models;
using OTEAServer.Services;

namespace OTEAServer.Controllers
{
    [ApiController]
    [Route("Indicators")]
    public class IndicatorsController : ControllerBase
    {
        private readonly ILogger<IndicatorsController> _logger;
        private readonly IndicatorsService _indicatorsService;

        public IndicatorsController(ILogger<IndicatorsController> logger, IndicatorsService indicatorsService)
        {
            _logger = logger;
            _indicatorsService = indicatorsService;
        }


        // GET all action
        [HttpGet]
        public IActionResult GetAll()
        {
            var indicators = _indicatorsService.GetAll();
            return Ok(indicators);
        }

        // GET all by INDICATORTYPE action
        [HttpGet("all::indicatorType={indicatorType}")]
        public IActionResult GetAllByType(string indicatorType)
        {
            var indicators = _indicatorsService.GetAllByType(indicatorType);
            return Ok(indicators);
        }

        // GET by ID AND INDICATOR TYPE action

        [HttpGet("get::idIndicator={idIndicator}:indicatorType={indicatorType}:indicatorVersion={indicatorVersion}")]
        public ActionResult<Indicator> Get(int idIndicator, string indicatorType, int indicatorVersion)
        {
            var indicator = _indicatorsService.Get(idIndicator,indicatorType,indicatorVersion);

            if (indicator == null)
                return NotFound();

            return indicator;
        }



        // POST action
        [HttpPost]
        public IActionResult Create([FromBody] Indicator indicator)
        {
            _indicatorsService.Add(indicator.indicatorId, indicator.indicatorType, indicator.descriptionEnglish, indicator.descriptionSpanish, indicator.descriptionFrench, indicator.indicatorPriority, indicator.indicatorVersion);
            return CreatedAtAction(nameof(Get), new { id = indicator.indicatorId, type=indicator.indicatorType }, indicator);
        }

        // PUT action
        [HttpPut("upd::idIndicator={idIndicator}:indicatorType={indicatorType}:indicatorVersion={indicatorVersion}")]
        public IActionResult Update(int idIndicator, string indicatorType, int indicatorVersion, [FromBody] Indicator indicator)
        {
            // This code will update the mesa and return a result
            if (idIndicator != indicator.indicatorId || indicatorType != indicator.indicatorType || indicatorVersion != indicator.indicatorVersion)
                return BadRequest();

            var existingIndicator = _indicatorsService.Get(idIndicator, indicatorType, indicatorVersion-1);
            if (existingIndicator is null)
                return NotFound();

            _indicatorsService.Update(idIndicator,indicatorType,indicatorVersion,indicator);

            return Ok(indicator);
        }

        // DELETE action
        [HttpDelete("del::idIndicator={idIndicator}:indicatorType={indicatorType}:indicatorVersion={indicatorVersion}")]
        public IActionResult Delete(int idIndicator, string indicatorType, int indicatorVersion)
        {
            // This code will delete the mesa and return a result
            var indicator = _indicatorsService.Get(idIndicator, indicatorType, indicatorVersion);

            if (indicator is null)
                return NotFound();

            _indicatorsService.Delete(idIndicator, indicatorType, indicatorVersion);

            return NoContent();
        }
    }
}

            
        \end{lstlisting}
        Como se puede comprobar en este controlador, todos los métodos vienen
        acompañados por \texttt{HttpGet}, \texttt{HttpPost}, \texttt{HttpPut} o
        \texttt{HttpDelete}, acompañados del endpoint correspondiente
        establecido. En el caso del \texttt{HttpPut}, siempre viene acompañado
        su parámetro por un \texttt{FromBody}, el cual indica que el objeto
        procede de un formato JSON. También cabe resaltar que antes de colocar
        el \texttt{public class}, se coloca con anterioridad
        \texttt{ApiController} y posteriormente \texttt{Route("Indicators")},
        que establecen el endpoint base de la API.
        \item \textbf{Services: }Este paquete incluye todas las clases en las que se apoyan los controladores para poder realizar las operaciones en la base de datos. Ejemplo: 
        \begin{lstlisting}
            using OTEAServer.Models;
using System.Data.SqlClient;

namespace OTEAServer.Services
{
    public class IndicatorsService
    {
        private static IConfiguration _configuration;
        public IndicatorsService(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        public List<Indicator> GetAll() {
            List<Indicator> indicatorsList = new List<Indicator>();

            string connectionString = _configuration.GetConnectionString("DefaultConnection");
            string query = "SELECT * FROM INDICATORS WHERE ISACTIVE=1 ORDER BY INDICATORID";

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();

                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            indicatorsList.Add(new Indicator(reader.GetInt32(0), reader.GetString(1), reader.GetString(2), reader.GetString(3), reader.GetString(4), reader.GetInt32(5), reader.GetInt32(6)));
                        }
                    }
                }
            }
            return indicatorsList;
        }

        public List<Indicator> GetAllByType(string indicatorType)
        {
            List<Indicator> indicatorsList = new List<Indicator>();

            string connectionString = _configuration.GetConnectionString("DefaultConnection");
            string query = "SELECT * FROM INDICATORS WHERE INDICATORTYPE=@INDICATORTYPE AND ISACTIVE=1 ORDER BY INDICATORID";

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();

                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@INDICATORTYPE", indicatorType);
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            indicatorsList.Add(new Indicator(reader.GetInt32(0), indicatorType, reader.GetString(2), reader.GetString(3), reader.GetString(4), reader.GetInt32(5), reader.GetInt32(6)));
                        }
                    }
                }
            }
            return indicatorsList;
        }

        public Indicator? Get(int idIndicator, string indicatorType, int indicatorVersion)
        {
            string connectionString = _configuration.GetConnectionString("DefaultConnection");
            string query = "SELECT * FROM INDICATORS WHERE indicatorId=@IDINDICATOR AND indicatorType=@INDICATORTYPE AND indicatorVersion=@INDICATORVERSION ORDER BY INDICATORID";

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();

                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@IDINDICATOR", idIndicator);
                    command.Parameters.AddWithValue("@INDICATORTYPE", indicatorType);
                    command.Parameters.AddWithValue("@INDICATORVERSION", indicatorVersion);
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            return new Indicator(idIndicator, indicatorType, reader.GetString(2), reader.GetString(3), reader.GetString(4), indicatorVersion, reader.GetInt32(6));
                        }
                    }
                }
            }
            return null;
        }

        public void Add(int idIndicator, string indicatorType, string descriptionEnglish, string descriptionSpanish, string descriptionFrench, int indicatorPriority, int indicatorVersion) 
        {
            string connectionString = _configuration.GetConnectionString("DefaultConnection");

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();

                // Crea el command SQL
                string sql = "INSERT INTO INDICATORS (INDICATORID,INDICATORTYPE,DESCRIPTIONENGLISH,DESCRIPTIONSPANISH,DESCRIPTIONFRENCH,INDICATORPRIORITY,INDICATORVERSION,ISACTIVE) VALUES (@IDINDICATOR,@INDICATORTYPE,@DESCRIPTIONENGLISH,@DESCRIPTIONSPANISH,@DESCRIPTIONFRENCH,@INDICATORPRIORITY,@INDICATORVERSION,1)";
                using (SqlCommand command = new SqlCommand(sql, connection))
                {
                    command.Parameters.AddWithValue("@IDINDICATOR", idIndicator);
                    command.Parameters.AddWithValue("@INDICATORTYPE", indicatorType);
                    command.Parameters.AddWithValue("@DESCRIPTIONENGLISH", descriptionEnglish);
                    command.Parameters.AddWithValue("@DESCRIPTIONSPANISH", descriptionSpanish);
                    command.Parameters.AddWithValue("@DESCRIPTIONFRENCH", descriptionFrench);
                    command.Parameters.AddWithValue("@INDICATORPRIORITY", indicatorPriority);
                    command.Parameters.AddWithValue("@INDICATORVERSION", indicatorVersion);

                    command.ExecuteNonQuery();
                }

                connection.Close();
            }
        }


        public void Delete(int idIndicator, string indicatorType, int indicatorVersion)
        {
            if (Get(idIndicator,indicatorType,indicatorVersion) != null)
            {
                string connectionString = _configuration.GetConnectionString("DefaultConnection");

                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    connection.Open();

                    // Crea el command SQL
                    string sql = "DELETE FROM INDICATORS WHERE indicatorId=@IDINDICATOR AND indicatorType=@INDICATORTYPE AND indicatorVersion=@INDICATORVERSION";
                    using (SqlCommand command = new SqlCommand(sql, connection))
                    {
                        command.Parameters.AddWithValue("@IDINDICATOR", idIndicator);
                        command.Parameters.AddWithValue("@INDICATORTYPE", indicatorType);
                        command.Parameters.AddWithValue("@INDICATORVERSION", indicatorVersion);

                        command.ExecuteNonQuery();
                    }
                    connection.Close();
                }
            }
        }

        public void Update(int idIndicator, string indicatorType, int indicatorVersion, Indicator indicator)
        {
            if (indicator != null && Get(idIndicator,indicatorType,indicatorVersion) != null && idIndicator==indicator.indicatorId && indicatorType==indicator.indicatorType && indicatorVersion==indicator.indicatorVersion-1) 
            {

                Add(indicator.indicatorId, indicator.indicatorType, indicator.descriptionEnglish, indicator.descriptionSpanish, indicator.descriptionFrench, indicator.indicatorPriority, indicator.indicatorVersion);

                string connectionString = _configuration.GetConnectionString("DefaultConnection");

                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    connection.Open();


                    string sql = "UPDATE USERS SET ISACTIVE=0 WHERE INDICATORID=@IDINDICATOR AND INDICATORTYPE=@INDICATORTYPE AND INDICATORVERSION=@INDICATORVERSION"; 
                    using (SqlCommand command = new SqlCommand(sql, connection))
                    {

                        command.Parameters.AddWithValue("@IDINDICATOR", indicator.indicatorId);
                        command.Parameters.AddWithValue("@INDICATORTYPE", indicator.indicatorType);
                        command.Parameters.AddWithValue("@INDICATORVERSION", indicator.indicatorVersion-1);

                        command.ExecuteNonQuery();
                    }

                    connection.Close();
                }
            }
        }
    }
}

        \end{lstlisting}
        En este caso se puede comprobar las diferentes operaciones que realiza el servicio de Indicadores. Todas ellas siguen una misma estructura. En primer lugar se tiene que llamar al \texttt{connectionString} procedente del fichero de configuración, más adelante construir la consulta parametrizada en SQL mediante \texttt{SqlCommand}, que se construye con la consulta parametrizada y con la conexión. Por último, utiliza el \texttt{reader} en las operaciones de GET.
    \end{itemize}
    \item En el lado del cliente también tenemos tres tipos de clase diferentes, pero llamadas de diferente forma:
    \begin{itemize}
        \item \textbf{Callers: }Son los métodos que se encargan de realizar de
        forma asíncrona las peticiones del servidor y a su vez procesar la
        respuesta del cliente, todo ello de forma asíncrona mediante
        \texttt{AsyncTask}. Dichos Callers sigue el patrón de diseño Singleton,
        ya que no es necesario contar con múltiples instancias de la clase,
        pudiendo crear una sola para cada uno de estos. Cuando se tienen
        múltiples instancias repartidas en el tiempo de ejecución, los tiempos
        de respuesta son muy lentos, por lo que utilizar este patrón de diseño
        es muy importante para poder acelerar dicho proceso. Ejemplo:
        \begin{lstlisting}
            public class IndicatorsCaller {

    private static IndicatorsApi api;
    private static IndicatorsCaller instance;

    private IndicatorsCaller(){
        api=ConnectionClient.getInstance().getRetrofit().create(IndicatorsApi.class);
    }

    public static IndicatorsCaller getInstance(){
        if(instance==null){
            synchronized (IndicatorsCaller.class){
                if(instance==null){
                    instance=new IndicatorsCaller();
                }
            }
        }
        return instance;
    }


    public static List<Indicator> obtainIndicators(String illness){
        Call<List<Indicator>> call=api.GetAllByType(illness);
        AsyncTask<Void, Void, List<Indicator>> asyncTask = new AsyncTask<Void, Void, List<Indicator>>() {
            List<Indicator> resultList= null;
            @Override
            protected List<Indicator> doInBackground(Void... voids) {
                try {
                    Response<List<Indicator>> response = call.execute();
                    if (response.isSuccessful()) {
                        return response.body();
                    } else {
                        throw new IOException("Error: " + response.code() + " " + response.message());
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            @Override
            protected void onPostExecute(List<Indicator> indicatorList) {
                resultList=indicatorList;
            }

        };
        asyncTask.execute();
        try {
            List<Indicator> list=asyncTask.get();
            return list;
        } catch (Exception e) {
            Log.d("ERROR", e.toString());
        }
        return null;
    }


    public static Indicator Update(int idIndicator, String indicatorType, int indicatorVersion, Indicator indicator){
        Call<Indicator> call=api.Update(idIndicator,indicatorType,indicatorVersion,indicator);
        AsyncTask<Void, Void, Indicator> asyncTask = new AsyncTask<Void, Void, Indicator>() {
            Indicator resultIndicator= null;
            @Override
            protected Indicator doInBackground(Void... voids) {
                try {
                    Response<Indicator> response = call.execute();
                    if (response.isSuccessful()) {
                        return response.body();
                    } else {
                        throw new IOException("Error: " + response.code() + " " + response.message());
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            @Override
            protected void onPostExecute(Indicator indicator) {
                resultIndicator=indicator;
            }

        };
        asyncTask.execute();
        try {
            Indicator i=asyncTask.get();
            return new Indicator(i.getIdIndicator(),i.getIndicatorType(),i.getDescriptionEnglish(),i.getDescriptionSpanish(),i.getDescriptionFrench(),i.getPriority(),i.getIndicatorVersion());
        } catch (Exception e) {
            Log.d("ERROR", e.toString());
        }
        return null;
    }

    public static Indicator Create(Indicator indicator){
        Call<Indicator> call=api.Create(indicator);
        AsyncTask<Void, Void, Indicator> asyncTask = new AsyncTask<Void, Void, Indicator>() {
            Indicator resultIndicator= null;
            @Override
            protected Indicator doInBackground(Void... voids) {
                try {
                    Response<Indicator> response = call.execute();
                    if (response.isSuccessful()) {
                        return response.body();
                    } else {
                        throw new IOException("Error: " + response.code() + " " + response.message());
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            @Override
            protected void onPostExecute(Indicator indicator) {
                resultIndicator=indicator;
            }

        };
        asyncTask.execute();
        try {
            Indicator i=asyncTask.get();
            return new Indicator(i.getIdIndicator(),i.getIndicatorType(),i.getDescriptionEnglish(),i.getDescriptionSpanish(),i.getDescriptionFrench(),i.getPriority(),i.getIndicatorVersion());
        } catch (Exception e) {
            Log.d("ERROR", e.toString());
        }
        return null;
    }

    public static Indicator Get(int idIndicator, String indicatorType, int indicatorVersion){
        Call<Indicator> call=api.Get(idIndicator,indicatorType,indicatorVersion);
        AsyncTask<Void, Void, Indicator> asyncTask = new AsyncTask<Void, Void, Indicator>() {
            Indicator resultIndicator= null;
            @Override
            protected Indicator doInBackground(Void... voids) {
                try {
                    Response<Indicator> response = call.execute();
                    if (response.isSuccessful()) {
                        return response.body();
                    } else {
                        throw new IOException("Error: " + response.code() + " " + response.message());
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            @Override
            protected void onPostExecute(Indicator indicator) {
                resultIndicator=indicator;
            }

        };
        asyncTask.execute();
        try {
            Indicator i=asyncTask.get();
            return new Indicator(i.getIdIndicator(),i.getIndicatorType(),i.getDescriptionEnglish(),i.getDescriptionSpanish(),i.getDescriptionFrench(),i.getPriority(),i.getIndicatorVersion());
        } catch (Exception e) {
            Log.d("ERROR", e.toString());
        }
        return null;
    }
    public static List<Indicator> GetAll(){
        Call<List<Indicator>> call=api.GetAll();
        AsyncTask<Void, Void, List<Indicator>> asyncTask = new AsyncTask<Void, Void, List<Indicator>>() {
            List<Indicator> resultList= null;
            @Override
            protected List<Indicator> doInBackground(Void... voids) {
                try {
                    Response<List<Indicator>> response = call.execute();
                    if (response.isSuccessful()) {
                        return response.body();
                    } else {
                        throw new IOException("Error: " + response.code() + " " + response.message());
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            @Override
            protected void onPostExecute(List<Indicator> indicatorList) {
                resultList=indicatorList;
            }

        };
        asyncTask.execute();
        try {
            List<Indicator> aux=asyncTask.get();
            List<Indicator> list=new LinkedList<>();
            for(Indicator i:aux){
                list.add(new Indicator(i.getIdIndicator(),i.getIndicatorType(),i.getDescriptionEnglish(),i.getDescriptionSpanish(),i.getDescriptionFrench(),i.getPriority(),i.getIndicatorVersion()));
            }
            return list;
        } catch (Exception e) {
            Log.d("ERROR", e.toString());
        }
        return null;
    }
    public static Indicator Delete(int idIndicator, String indicatorType, int indicatorVersion){
        Call<Indicator> call=api.Get(idIndicator,indicatorType,indicatorVersion);
        AsyncTask<Void, Void, Indicator> asyncTask = new AsyncTask<Void, Void, Indicator>() {
            Indicator resultIndicator= null;
            @Override
            protected Indicator doInBackground(Void... voids) {
                try {
                    Response<Indicator> response = call.execute();
                    if (response.isSuccessful()) {
                        return response.body();
                    } else {
                        throw new IOException("Error: " + response.code() + " " + response.message());
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            @Override
            protected void onPostExecute(Indicator indicator) {
                resultIndicator=indicator;
            }

        };
        asyncTask.execute();
        try {
            return asyncTask.get();
        } catch (Exception e) {
            Log.d("ERROR", e.toString());
        }
        return null;
    }
}
        \end{lstlisting}
        Como se puede comprobar, todos los métodos utilizan en primer lugar
        \texttt{AsyncTask} para poder comunicarse con la API, que contiene el
        endpoint referenciado en el servidor, cuya URL base se encuentra en la
        clase \texttt{ConnectionClient}, la cual utiliza también el patrón
        Singleton por el mismo motivo que los callers. \texttt{ASyncTask} se
        encarga de llamar al método de la API para luego procesar la respuesta.
        El método siempre devuelve \texttt{asyncTask.get()}, el cual devuelve la
        respuesta de forma bloqueante.
        \item \textbf{Api: }Las API en Java están definidas como interfaces. Las llamadas a los endpoint se realizan mediante \textit{Retrofit}, como se ha mencionado en la memoria. Ejemplo:
        \begin{lstlisting}
            public interface IndicatorsApi {
                @PUT("Indicators/upd::idIndicator={idIndicator}:indicatorType={indicatorType}:indicatorVersion={indicatorVersion}")
                Call<Indicator> Update(@Path("idIndicator") int idIndicator, @Path("indicatorType") String indicatorType, @Path("indicatorVersion") int indicatorVersion, @Body Indicator indicator);
                @POST("Indicators")
                Call<Indicator> Create(@Body Indicator indicator);
                @GET("Indicators/get::idIndicator={idIndicator}:indicatorType={indicatorType}:indicatorVersion={indicatorVersion}")
                Call<Indicator> Get(@Path("idIndicator") int idIndicator, @Path("indicatorType") String indicatorType, @Path("indicatorVersion") int indicatorVersion);
                @GET("Indicators")
                Call<List<Indicator>> GetAll();
                @GET("Indicators/all::indicatorType={indicatorType}")
                Call<List<Indicator>> GetAllByType(@Path("indicatorType") String indicatorType);
                @DELETE("Indicators/del::idIndicator={idIndicator}:indicatorType={indicatorType}:indicatorVersion={indicatorVersion}")
                Call<Indicator> Delete(@Path("idIndicator") int idIndicator, @Path("indicatorType") String indicatorType, @Path("indicatorVersion") int indicatorVersion);
            }
        \end{lstlisting}
        Como se puede apreciar, todos los métodos vienen con la notación \texttt{GET, POST, PUT o DELETE} acompañada de su endpoint correspondiente. Si se desean añadir datos a los endpoint se tiene que utilizar \texttt{Path}, mientras que para los \texttt{POST} se tiene que utilizar \texttt{BODY} para la serialización en JSON
        \item \textbf{Modelos: }Se trata de las propias clases de Java. Ejemplo:
        \begin{lstlisting}
            public class Indicator implements Serializable {

                    @SerializedName("indicatorId")
                    public int indicatorId;

                    @SerializedName("indicatorType")
                    public String indicatorType;

                    @SerializedName("descriptionEnglish")
                    public String descriptionEnglish;
                    @SerializedName("descriptionSpanish")
                    public String descriptionSpanish;
                    @SerializedName("descriptionFrench")
                    public String descriptionFrench;

                    @SerializedName("indicatorPriority")
                    public int indicatorPriority;

                    @SerializedName("indicatorVersion")
                    public int indicatorVersion;

                    public Indicator(int indicatorId, String indicatorType, String descriptionEnglish,String descriptionSpanish,String descriptionFrench, int indicatorPriority, int indicatorVersion) {
                        setIdIndicator(indicatorId);
                        setIndicatorType(indicatorType);
                        setDescriptionEnglish(descriptionEnglish);
                        setDescriptionSpanish(descriptionSpanish);
                        setDescriptionFrench(descriptionFrench);
                        setPriority(indicatorPriority);
                        setIndicatorVersion(indicatorVersion);
                    }
            }
        \end{lstlisting}
        Como se puede apreciar, todos los campos de la clase vienen acompañados por \texttt{SerializedName} acompañado del nombre que recibe el cliente de los JSON. El modelo implementa serializable para poder pasar los objetos entre las propias actividades de la aplicación.
    \end{itemize}
\end{itemize}

Por lo tanto, la comunicación de todos los casos entre cliente y servidor es la siguiente:
\imagen{./Figuras/Diagramas/CSAddresses.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Address}
\imagen{./Figuras/Diagramas/CSCenter.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Center}
\imagen{./Figuras/Diagramas/CSCity.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase City}
\imagen{./Figuras/Diagramas/CSCountry.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Country}
\imagen{./Figuras/Diagramas/CSEvaluatorTeamMembers.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase EvaluatorTeamMember}
\imagen{./Figuras/Diagramas/CSEvaluatorTeams.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase EvaluatorTeam}
\imagen{./Figuras/Diagramas/CSEvidence.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Evidence}
\imagen{./Figuras/Diagramas/CSIndicator.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Indicator}
\imagen{./Figuras/Diagramas/CSIndicatorsEvaluationRegs.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase IndicatorsEvaluationReg}
\imagen{./Figuras/Diagramas/CSIndicatorsEvaluations.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase IndicatorsEvaluation}
\imagen{./Figuras/Diagramas/CSOrganization.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Organization}
\imagen{./Figuras/Diagramas/CSProvince.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Province}
\imagen{./Figuras/Diagramas/CSRegion.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase Region}
\imagen{./Figuras/Diagramas/CSUser.png}{Esquema de comunicación entre el cliente (lado derecho) y el servidor (lado izquierdo), para la clase User}
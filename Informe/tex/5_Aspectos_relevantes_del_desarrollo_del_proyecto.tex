\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}


\section{Ciclo de vida utilizado}
El ciclo de vida utilizado para el desarrollo de esta aplicación, que se ha
procurado seguir durante todo el tiempo de desarrollo, es un ciclo de vida de
tipo ágil. Se ha escogido este tipo de ciclo de vida puesto que permite tener el
control de todos los aspectos de las diferentes fases de desarrollo de la
aplicación, tanto a nivel de desarrollo como a nivel de documentación,
permitiendo también la alternancia entre fases acorde con las necesidades del
proyecto. \\

Un ciclo de vida ágil consiste en una entrega de forma incremental de las
diferentes características de la aplicación y mejora de las características ya
existentes de la misma. Durante este ciclo de vida se han ido subiendo
diferentes modificaciones tanto a \textit{GitHub} como a \textit{Trello}, las
cuales son denominadas como sprints. Cada sprint representa una actualización de
una característica o conjunto de características de la aplicación o de los
anexos, las cuales ayudan a marcar qué actividad se ha realizado y en qué
momento se ha realizado.
\\
En este caso, se ha utilizado un método visual de Kanban.\cite{Kanban}

Kanban es un método de gestión del flujo de trabajo para definir, gestionar y
mejorar los servicios que proporciona el trabajo de conocimiento, siendo de gran
ayuda para la visualización del trabajo, la optimización de la eficiencia y la
continuación de diferentes mejoras. El trabajo se representa en tableros Kanban,
lo que permite optimizar la entrega de trabajo a través de múltiples equipos
y manejar, incluso los proyectos más complejos en un solo entorno. \\ 

La implementación de este modelo de ciclo de vida el ha sido posible gracias a
\textit{Trello}, que es una herramienta muy útil para la gestión de proyectos a
nivel visual en el que cual se tienen diferentes columnas sobre las actividades
por hacer, las actividades en realización, las actividades realizadas y las
diferentes reuniones de seguimiento que se han tenido con el tutor.
\imagen{Figuras/Aspectos relevantes/Trello.png}{Uso de \textit{Trello} para el
proyecto}{1} Como se puede comprobar en la siguiente captura, durante todo este
tiempo se han colocado diferentes columnas en las que se han colocado diferentes
aspectos:
\begin{itemize}
    \item \textbf{Dudas a resolver lo antes posible: }En este apartado el alumno
    tiene la posibilidad de colocar esas inquietudes que tiene en cualquier
    aspecto relacionado con el proyecto sin necesidad de comentarlo
    explícitamente en cualquiera de las reuniones de seguimiento que se han ido
    realizando durante el curso.
    \item \textbf{Tareas en realización: }En este apartado se introducen las
    tareas en realización en ese mismo momento, las cuales se han ido marcando
    en cada una de las reuniones de seguimiento a lo largo de todo el tiempo de
    desarrollo.
    \item \textbf{Tareas para próximos sprint: }En este apartado se introducen
    las tareas que se realizarán para próximos sprints.
    \item \textbf{Próxima reunión: }En este apartado se introduce la información
    sobre la fecha de la próxima reunión y a la hora en la que tendrá lugar.
    Durante todo este tiempo las reuniones han tenido lugar los martes de cada
    semana por la mañana, ya sea a las 11:30 horas o a las 13:00 horas.
    \item \textbf{Tareas ya realizadas: }En este apartado se introducen todas
    las tareas que ya han sido realizadas durante el tiempo de desarrollo.
    \item \textbf{Información de las reuniones realizadas: }En este apartado se
    registran todas las reuniones realizadas durante todo este tiempo. Todas
    ellas han estado en el apartado anterior.
\end{itemize}



\section{Fases de análisis, diseño e implementación}
Para poder seguir el ciclo de vida anteriormente mencionado, se tienen que tener
claras las fases a seguir durante todo el proceso de desarrollo. Al tratarse de
un ciclo de vida ágil, cabe resaltar que el paso entre fases es cíclico puesto
que, como se ha mencionado con anterioridad, conviene que el proceso de
desarrollo de la aplicación se adapte a las necesidades que se vayan teniendo a
lo largo del proyecto, por lo que las fases de \textit{análisis},
\textit{diseño} e \textit{implementación} se van alternando a lo largo del
tiempo. 



\subsection{Análisis}
%Se describirá el proceso de análisis realizado, incluyendo las técnicas utilizadas para recopilar los requisitos del sistema, como entrevistas con los usuarios, revisiones de documentos existentes o análisis de casos de uso. Se resaltarán los desafíos y las decisiones clave tomadas durante esta etapa.
El análisis del entorno ha sido realizado con la ayuda principal de la
aplicación en Microsoft Access, la cual ha servido como punto de referencia para
montar las bases en las que se apoya dicha aplicación. 
\\En la aplicación Access ya había posibilidad de registrar organizaciones, de
crear equipos evaluadores, de realizar test de indicadores y de guardar los
registros de dichos test de indicadores en la base de datos en este mismo
programa. Era un procedimiento bastante arcaico el uso de esa aplicación, por lo
que se ha tenido que plantear que nuevas características se pretenden añadir en
esta nueva versión:
\begin{itemize}
    \item En primer lugar, la aplicación tiene que almacenar los usuarios
    mediante el registro de los mismos en la base datos, en lugar de hacerlo
    directamente en el apartado de equipos evaluadores. Los usuarios se segregan
    en tres categorías diferentes:
    \begin{itemize}
        \item \textbf{Usuarios de la Fundación Miradas o usuarios de
        organización evaluadora: }Estos usuarios tienen la capacidad de crear
        equipos evaluadores, de añadir organizaciones nuevas y centros nuevos, y
        de poder crear y visualizar evaluaciones de indicadores. 
        \item \textbf{Usuarios de organización evaluada: }Estos usuarios
        pertenecen a las organizaciones que participan en estos test de
        indicadores junto con la \textit{Fundación Miradas}. Dichos usuarios
        tienen la capacidad de ver los resultados de los diferentes equipos
        evaluadores 
        \item \textbf{Administrador: }Es el encargado de gestionar las tablas de
        la base de datos, ya sea creando nuevas, eliminando existentes y
        modificando las columnas de las mismas. Es el único de los tres tipos de usuarios
        que no se puede registrar de la forma habitual.
    \end{itemize}
    Se ha decidido segregar de esta forma a los usuarios por pura distinción de
    sus responsabilidades (\textit{Para ver más detalles ir al capítulo de
    Requisitos en los anexos}), algo que en la aplicación antigua de Access no
    se tenía o no se necesitaba tener en cuenta en su momento.
    \item Al igual que los usuarios, la segregación de organizaciones es también
    un factor de vital importancia. Dicha segregación es en la que se basan los
    usuarios para determinar si el usuario es de la \textit{Fundación Miradas} o
    por lo contrario si es un usuario de otra organización. Cada una de las
    organizaciones se identifican por \textbf{identificador de organización} de
    tipo entero, un \textbf{tipo de organización} que puede ser
    \textit{EVALUATED} o \textit{EVALUATOR} y una \textbf{enfermedad}, que en
    nuestro caso siempre es \textit{AUTISM}. Se ha decidido que se identifiquen
    de esta manera para que esta entidad pueda ser utilizada también para otro
    tipo de diagnósticos o enfermedades, requisito exigido por el tribunal antes
    de comenzar con el desarrollo. Por lo tanto, nos podemos encontrar con dos
    grandes tipos de organizaciones:
    \begin{itemize}
        \item \textbf{Organizaciones evaluadoras (\textit{Fundación Miradas}): }
        Dichas organizaciones no pueden ser añadidas como tal desde la
        aplicación, ya que la propia \textit{Fundación Miradas} es la encargada
        de añadir organizaciones evaluadas, como se ha relatado con
        anterioridad. Para poder añadir una se tendría que utilizar
        \textit{cURL} o \textit{Azure Studio}. También tiene la potestad de
        añadir nuevos equivos evaluadores y de gestionar los test de
        indicadores.
        \item \textbf{Organizaciones evaluadas: }Son las organizaciones que se
        someten a los diferentes test de indicadores. En contraparte con el otro
        tipo de organizaciones, éstas sí que pueden ser añadidas a partir de la
        propia aplicación, mediante el formulario de agregación de
        organizaciones. (\textit{Véase manual de usuario en los Anexos o vídeos incluidos en el repositorio})
    \end{itemize}
    \item También se tiene que tener el control de los equipos evaluadores por
    parte exclusiva de los usuarios de la \textit{Fundación Miradas}, a
    diferencia de la aplicación en Access la cual no hace distinción, como se ha
    mencionado con anterioridad. La estructura de los equipos evaluadores no ha
    cambiado con respecto a Access.
    \item La realización de las pruebas de indicadores también sigue la misma
    dinámica, con la diferencia de que la realización de los mismos es más
    intuitiva y rápida gracias al uso en pantallas táctiles.
\end{itemize}

Teniendo en cuenta esos aspectos, se ha realizado tanto el análisis de los casos
de uso, el cual se encuentra en el capítulo de requisitos de los anexos, como el
diagrama de clases.
\\
En cuanto a la toma de decisiones, al principio del desarrollo se pretendía
unificar todo bajo el mismo lenguaje \textit{Java}, ya que cuento con la
experiencia en este lenguaje que se ha ido proporcionando a lo largo de las
asignaturas del grado. Para la comunicación con la base de datos se utilizaba
\textit{JDBC}, el cual ejecuta las consultas SQL desde el propio código. Durante
gran parte del tiempo de desarrollo de la aplicación, se han ido encontrando
diferentes dificultades para poder ejecutar dichas órdenes en la base de datos,
puesto que todo aquello que requiera una conexión a internet desde una
aplicación Android, requiere que sea ejecutado en segundo plano, ya sea mediante
\textit{ASyncTask}, mediante callbacks o mediante técnicas de programación
concurrente. Ese inconveniente obligó a empezar a trabajar con las operaciones
al servidor en segundo plano, puesto que en un hilo tiene que estar ejecutándose
la aplicación y en otro tiene que estar ejecutándose la solicitud al servidor.
También se pretendía montar el servicio web en \textit{JAX-RS} para que pueda
realizar esas operaciones en la base de datos mediante \textit{JDBC}. Aunque
esta técnica funcionaba correctamente, el procesamiento de la respuesta en Azure
era bastante más lento debido a que no está integrado en Azure, en comparación a
\textit{C\#} y al framework \textit{ASP.NET}, los cuales por su integración en
Azure tiene unos tiempos de respuesta bastante más rápidos en comparación con su
semejante en \textit{Java}.


\subsection{Diseño}
%Se explicará la arquitectura seleccionada para la aplicación, justificando las
%razones detrás de esta elección. Se detallarán los patrones de diseño
%utilizados y cómo se aplicaron a la solución. También se abordarán los aspectos
%relacionados con la base de datos, como el diseño de tablas, los índices
%utilizados, la normalización y desnormalización, así como cualquier regla de
%negocio implementada en la base de datos.
\imagen{Figuras/Aspectos relevantes/MVC.png}{Estructura básica de la arquitectura \textit{Modelo-Vista-Controlador}}{0.6} 
En este caso se ha elegido como arquitectura el modelo denominado
\textit{Modelo-Vista-Controlador}. Dicho modelo segrega las diferentes
responsabilidades que tienen los usuarios en los que cada una de las tres capas
(\textit{Modelo, Vista y Controlador}) tiene unas reglas exclusivas de ellas mismas.
\begin{itemize}
    \item \textbf{Modelo: }El modelo se encarga de almacenar las diferentes
    entidades con las que interactúa el servidor, para poder realizar así las
    peticiones y poder devolver correctamente la respuesta al cliente, previa
    serialización en el cliente y previa deserialización en el servidor. En este
    caso el modelo consta de las clases \textit{User, Organization, Indicator,
    Evidence, Center, Address, City, Province, Region, Country, EvaluatorTeam,
    EvaluatorTeamMember, IndicatorsEvaluation} e
    \textit{IndicatorsEvaluationReg} (\textit{Véase más información acerca de
    los modelos en el capítulo de Diseño de los Anexos}). Cabe resaltar también
    que el modelo tiene que ser idéntico tanto en el cliente como en el
    servidor, para evitar así diferentes problemas en la serialización y
    deserialización de dichas entidades. 
    \item \textbf{Vista: }La vista consiste en la forma en la que se muestran el
    contenido de las respuestas de las peticiones en la base de datos. También
    se incluye en este apartado la interfaz gráfica con la que interactúan los
    usuarios. En este caso, como cada tipo de usuario tiene responsabilidades
    diferentes, se considera que esta aplicación tiene diferentes vistas, todo
    por las responsabilidades que tienen los usuarios. En nuestro caso, la vista
    es proporcionada al cliente mediante las clases denominadas \textit{Caller},
    las cuales se encargan de enviar la solicitud al endpoint correspondiente
    del servidor y de procesar correctamente la respuesta que éste le da.
    \item \textbf{Controlador: }El controlador se encarga de realizar las
    peticiones a la base de datos previa solicitud del cliente. El controlador
    puede realizar todo tipo de operaciones \textit{CRUD (Create, Read, Update,
    Delete)} de la base de datos, encargándose también de marcar los endpoints
    en los que se van a realizar dichas operaciones. Dichos métodos del
    controlador se apoyan en los \textit{Services} que realizan la consulta de
    la base de datos, todo ello en el lado del servidor.
\end{itemize}

Se ha optado por esta arquitectura debido a que se busca el control necesario
para todo el proceso de las peticiones HTTP entre el cliente y el servidor. En
primer lugar los modelos son los que se encargan de establecer la estructura
JSON de las peticiones, de tal forma que en el proceso de serialización y de
deserialización los campos sean asignados correctamente, para que la vista
muestre las respuestas de la manera esperada de las peticiones de las
operaciones realizadas por el controlador.

En cuanto a la base de datos se cuentan con las siguientes entidades SQL, se
utiliza \texttt{CREATE TABLE} para poder crear las tablas, \texttt{INSERT INTO
nombre\_tabla VALUES} para modificar las tablas, \texttt{UPDATE nombre\_tabla SET
columna=valor WHERE columna=valor\_old} para actualizar la columna,
\texttt{SELECT * FROM nombre\_tabla} para mostrar los registros de una tabla y
\texttt{DELETE * FROM nombre\_tabla} para hacer el delete de esa tabla. Para la
información sobre la estructura de las entidades, \textit{véase el capítulo de
diseño de los anexos.}

 


\subsection{Implementación}
%Se comentarán los aspectos más destacados de la implementación, como las
%tecnologías y lenguajes de programación utilizados. Se discutirán las
%decisiones técnicas importantes, como la selección de frameworks, bibliotecas o
%herramientas de desarrollo. Se podrán mencionar problemas encontrados durante
%la implementación y cómo se resolvieron.
En cuanto a la implementación de la aplicación, se han ido encontrando
diferentes problemas que se han ido solventando con el paso del tiempo, quedando
algunas pendientes de resolver. Los errores que se han ido encontrando a lo
largo del tiempo son los siguientes:
\begin{itemize}
    \item \texttt{Android.NetworkOnMainThreadException: } Esta excepción ha
    saltado sobre todo al principio del proceso de desarrollo, en la que se
    estaba intentando conectar directamente la base de datos local a la
    aplicación sin intermediario alguno como el caso de un servidor. Esta
    excepción sale debido a que las operaciones de la base de datos y de
    comunicación pretenden hacerse en el mismo hilo en el que se ejecuta la
    aplicación, haciendo que esta se cierre repentinamente por esa incorrecta
    gestión de hilos. Para evitar que salte esta excepción en el cliente, se
    tiene que montar esa estructura \textit{Modelo-Vista-Controlador} en el
    cliente vista con anterioridad, utilizando cualquier técnica de manejo de
    hilos, decantándome por \textit{ASyncTask} por la razón mencionada en el
    capítulo anterior, donde se menciona la herramienta y las posibles
    alternativas a la misma.
    \item \texttt{400 Bad Request: } Esta excepción ha saltado debido a que el
    JSON no ha sido generado correctamente. Este fallo surge debido a un
    problema en la estructura del modelo o la serialización en el lado del
    cliente, ya que la forma en la que se envía el JSON no depende como tal del
    lado del servidor, que puede estar funcionando correctamente. Para evitar
    que salga este código de error, hay que asegurarse que en el cliente los
    campos se llamen exactamente igual que en el JSON que recibe el cliente, al
    igual que en el servidor y en la propia base de datos.
    \item {500 Internal Server Error: } Esta excepción surge por un problema interno en el servidor, por lo que el cliente no tiene por qué tener fallos en el modelo o en el procesamiento de la respuesta. Este fallo puede surgir por diferentes razones, por lo que es buena práctica hacer un debug en local del lado del servidor mediante una llamada al endpoint desde herramientas como  \textit{cURL}. Ejemplo: \begin{lstlisting}
        curl -X POST -H "Content-Type: application/json" -d "{\"idOrganization\":1,\"orgType\":\"EVALUATED\",\"illness\":\"AUTISM\",\"idCenter\":1,\"centerDescription\":\"Sede principal\",\"idAddress\":2,\"telephone\":987654321}" https://localhost:7049/Centers
    \end{lstlisting}
    Hay que considerar también que los puntos clave o breakpoints tienen que
    estar activados según la conveniencia que tenga el usuario en ese momento,
    así se puede observar paso a paso el motivo los pasos a seguir hasta llegar
    a la zona crítica. Este error puede surgir por sintaxis en la orden SQL y
    por violaciones de claves primarias y foráneas, al igual que por cualquier
    tipo de error que surja en el servidor.
\end{itemize}


\subsection{Internacionalización}

La internacionalización de una aplicación es un aspecto clave para garantizar su
accesibilidad y usabilidad en diferentes países y culturas. En el caso de una
aplicación de Android Studio, es posible implementar la internacionalización de
manera efectiva utilizando diferentes recursos proporcionados por la plataforma.
A continuación, se presenta un apartado sobre la internacionalización de la
aplicación, considerando los idiomas español, inglés y francés, y la posibilidad
de ampliarlo a otros idiomas en el futuro:

\begin{itemize}
    \item \textbf{Internacionalización de la interfaz gráfica: }La interfaz
    gráfica de la aplicación se ha traducido a tres idiomas: español, inglés y
    francés. Android Studio proporciona una herramienta llamada\textit{
    Translations Editor} que facilita la gestión de los ficheros strings.xml
    para cada idioma. Esta herramienta permite configurar de manera interactiva
    los textos de la interfaz en los diferentes idiomas. ara implementar la
    internacionalización de la interfaz gráfica en la aplicación, se deben
    seguir los siguientes pasos:
    \begin{itemize}
        \item \textit{Creación de ficheros strings.xml:} Para cada idioma, se deben crear
        ficheros strings.xml separados en diferentes directorios. Por ejemplo:
        strings.xml para el idioma por defecto (inglés) en el directorio
        \textit{values}, strings.xml para el español en el directorio
        \textit{values-es} y strings.xml para el francés en el directorio \textit{strings-fr}.
    
        \item \textit{Definición de cadenas de texto:} En cada fichero strings.xml, se
        deben definir las cadenas de texto utilizadas en la interfaz gráfica de
        la aplicación. Cada cadena debe tener un identificador único y su
        correspondiente traducción en el idioma correspondiente.
        
        \item \textit{Acceso a las cadenas de texto en el código:} Para mostrar las
        cadenas de texto en la interfaz, se debe acceder a ellas mediante su
        identificador en el código de la aplicación. Por ejemplo, utilizando
        \texttt{getString(R.string.mi\_cadena).}
    
        
        
    \end{itemize}
    Con estos pasos, la interfaz gráfica de la aplicación estará
    internacionalizada y mostrará los textos correspondientes al idioma
    configurado en el dispositivo siempre y cuando éste esté disponible.
    \item \textbf{Internacionalización de los datos obtenidos de la base de
    datos: }Además de la interfaz gráfica, es importante internacionalizar los
    datos obtenidos de la base de datos de la aplicación. En este caso, se ha
    optado por utilizar la biblioteca Locale de Java para detectar el idioma del
    dispositivo y mostrar los indicadores y evidencias en el idioma
    correspondiente.Para implementar la internacionalización de los datos, se
    pueden seguir los siguientes pasos:
    
\begin{itemize}
    \item \textit{Obtención del idioma del dispositivo:} Utilizando la clase \texttt{Locale} de
    Java, se puede obtener el idioma configurado en el dispositivo. Por ejemplo:
    \texttt{Locale.getDefault().getLanguage()}.
    \item \textit{Obtención de los datos de la base de datos:} Al obtener los
    datos de indicadores y evidencias de la base de datos, se deben considerar
    las traducciones correspondientes para cada idioma. Por ejemplo, si el
    idioma del dispositivo es español, se deben obtener los datos en español; si
    es francés, se deben obtener en francés; de lo contrario, se obtienen en
    inglés.
    \item \textit{Visualización de los datos en la interfaz:} Una vez obtenidos
    los datos en el idioma correspondiente, se pueden mostrar enla interfaz de
    la aplicación según el diseño y la estructura definida.
\end{itemize}
    
    Es importante tener en cuenta que la implementación de la
    internacionalización para los datos de la base de datos puede variar según
    la estructura y la forma en que se accede a los datos en la aplicación. La
    biblioteca \textit{Locale} de Java proporciona diferentes métodos y opciones para
    adaptar la aplicación al idioma del dispositivo.
    
\end{itemize}





